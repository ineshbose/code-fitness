
@book{sommervilleSoftwareEngineering1992,
	title = {Software {Engineering}},
	isbn = {978-0-201-56529-4},
	abstract = {"Software Engineering" presents a broad perspective on software systems engineering, concentrating on widely-used techniques for developing large-scale software systems. This best-selling book covers a wide spectrum of software processes from initial requirements elicitation through design and development to system evolution. It supports students taking undergraduate and graduate courses in software engineering. The sixth edition has been restructured and updated, important new topics have been added and obsolete material has been cut. Reuse now focuses on component-based development and patterns; object-oriented design has a process focus and uses the UML; the chapters on requirements have been split to cover the requirements themselves and requirements engineering process; cost estimation has been updated to include the COCOMO 2 model.},
	language = {en},
	publisher = {Addison-Wesley},
	author = {Sommerville, Ian},
	year = {1992},
	note = {Google-Books-ID: DoJQAAAAMAAJ},
}

@article{IEEEStandardGlossary1990,
	title = {{IEEE} {Standard} {Glossary} of {Software} {Engineering} {Terminology}},
	doi = {10.1109/IEEESTD.1990.101064},
	abstract = {This IEEE Standards product is part of the family on Software Engineering. This standard identifies terms currently in use in the field of Software Engineering. Standard definitions for those terms are established.},
	journal = {IEEE Std 610.12-1990},
	month = dec,
	year = {1990},
	note = {Conference Name: IEEE Std 610.12-1990},
	keywords = {Definitions, Software engineering, Standards, Terminology, dictionary, glossary, terminology},
	pages = {1--84},
}

@book{pressmanSoftwareEngineering3rd1992,
	address = {USA},
	title = {Software engineering (3rd ed.): a practitioner's approach},
	isbn = {978-0-07-050814-9},
	shorttitle = {Software engineering (3rd ed.)},
	publisher = {McGraw-Hill, Inc.},
	author = {Pressman, Roger S.},
	year = {1992},
}

@article{alomarScenesRelationshipDeveloper,
	title = {Behind the scenes: {On} the relationship between developer experience and refactoring},
	volume = {n/a},
	issn = {2047-7481},
	shorttitle = {Behind the scenes},
	url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/smr.2395},
	doi = {10.1002/smr.2395},
	abstract = {Refactoring is widely recognized as one of the efficient techniques to manage technical debt and maintain a healthy software project through enforcing best design practices, or coping with design defects. Previous refactoring surveys have shown that code refactoring activities are mainly executed by developers who have sufficient knowledge of the system's design, and disposing of leadership roles in their development teams. However, these surveys were mainly limited to specific projects and companies. In this paper, we explore the generalizability of the previous results by analyzing 800 open-source projects. We mine their refactoring activities, and we identify their corresponding contributors. Then, we associate an experience score to each contributor in order to test various hypotheses related to whether developers with higher scores tend to (1) perform a higher number of refactoring operations, (2) exhibit different motivations behind their refactoring, and (3) better document their refactoring activity. We found that (1) although refactoring is not restricted to a subset of developers, those with higher contribution scores tend to perform more refactorings than others; (2) although there is no correlation between experience and motivation behind refactoring, top contributed developers are found to perform a wider variety of refactoring operations, regardless of their complexity; and (3) top contributed developer tend to document less their refactoring activity. Our qualitative analysis of three randomly sampled projects shows that the developers who are responsible for the majority of refactoring activities are typically in advanced positions in their development teams, demonstrating their extensive knowledge of the design of the systems they contribute to.},
	language = {en},
	number = {n/a},
	urldate = {2022-12-10},
	journal = {Journal of Software: Evolution and Process},
	author = {Alomar, Eman Abdullah and Peruma, Anthony and Mkaouer, Mohamed Wiem and Newman, Christian D. and Ouni, Ali},
	note = {\_eprint: https://onlinelibrary.wiley.com/doi/pdf/10.1002/smr.2395},
	keywords = {developer experience, mining software repositories, quality, software maintenance and evolution, software refactoring},
	pages = {e2395},
}

@inproceedings{fagerholmDeveloperExperienceConcept2012,
	title = {Developer experience: {Concept} and definition},
	shorttitle = {Developer experience},
	doi = {10.1109/ICSSP.2012.6225984},
	abstract = {New ways of working such as globally distributed development or the integration of self-motivated external developers into software ecosystems will require a better and more comprehensive understanding of developers' feelings, perceptions, motivations and identification with their tasks in their respective project environments. User experience is a concept that captures how persons feel about products, systems and services. It evolved from disciplines such as interaction design and usability to a much richer scope that includes feelings, motivations, and satisfaction. Similarly, developer experience could be defined as a means for capturing how developers think and feel about their activities within their working environments, with the assumption that an improvement of the developer experience has positive impacts on characteristics such as sustained team and project performance. This article motivates the importance of developer experience, sketches related approaches from other domains, proposes a definition of developer experience that is derived from similar concepts in other domains, describes an ongoing empirical study to better understand developer experience, and finally gives an outlook on planned future research activities.},
	booktitle = {2012 {International} {Conference} on {Software} and {System} {Process} ({ICSSP})},
	author = {Fagerholm, Fabian and Münch, Jürgen},
	month = jun,
	year = {2012},
	keywords = {Developer experience, Human factors, Humans, Integrated circuit modeling, Productivity, Programming, Software, Software engineering, high-performing teams, human factors, software development environment, software psychology},
	pages = {73--77},
}

@article{lopez-fernandezDevOpsTeamStructures2022,
	title = {{DevOps} {Team} {Structures}: {Characterization} and {Implications}},
	volume = {48},
	issn = {1939-3520},
	shorttitle = {{DevOps} {Team} {Structures}},
	doi = {10.1109/TSE.2021.3102982},
	abstract = {Context: DevOps can be defined as a cultural movement to improve and accelerate the delivery of business value by making the collaboration between development and operations effective. Objective: This paper aims to help practitioners and researchers to better understand the organizational structure and characteristics of teams adopting DevOps. Method: We conducted an exploratory study by leveraging in-depth, semi-structured interviews with relevant stakeholders of 31 multinational software-intensive companies, together with industrial workshops and observations at organizations’ facilities that supported triangulation. We used Grounded Theory as qualitative research method to explore the structure and characteristics of teams, and statistical analysis to discover their implications in software delivery performance. Results: We describe a taxonomy of team structures that shows emerging, stable and consolidated product teams that are classified according to six variables, such as collaboration frequency, product ownership sharing, and autonomy, among others, as well as their implications on software delivery performance. These teams are often supported by horizontal teams (DevOps platform teams, Centers of Excellence, and chapters) that provide them with platform technical capabilities, mentoring and evangelization, and even temporarily may facilitate human resources. Conclusion: This study aims to strengthen evidence and support practitioners in making better informed about organizational team structures by analyzing their main characteristics and implications in software delivery performance.},
	number = {10},
	journal = {IEEE Transactions on Software Engineering},
	author = {López-Fernández, Daniel and Díaz, Jessica and García, Javier and Pérez, Jorge and González-Prieto, Ángel},
	month = oct,
	year = {2022},
	note = {Conference Name: IEEE Transactions on Software Engineering},
	keywords = {Collaboration, Companies, DevOps, Interviews, Software, Stakeholders, Taxonomy, Telecommunications, grounded theory, team structures},
	pages = {3716--3736},
}

@article{heTeamCognitionDevelopment2007,
	title = {Team {Cognition}: {Development} and {Evolution} in {Software} {Project} {Teams}},
	volume = {24},
	issn = {0742-1222},
	shorttitle = {Team {Cognition}},
	url = {https://doi.org/10.2753/MIS0742-1222240210},
	doi = {10.2753/MIS0742-1222240210},
	abstract = {In software development, team-based work structures are commonly used to accomplish complex projects. Software project teams must be able to utilize the expertise and knowledge of participants without overwhelming individual members. To efficiently leverage individuals' knowledge and expertise, software project teams develop team cognition structures that facilitate their knowledge activities. This study focuses on the emergence and evolution of team cognition in software project teams, and examines how communication activity and team diversity impact the formation of these structures. A longitudinal study was conducted of 51 database development teams. The results suggest that some forms of communication and team diversity affect the formation of team cognition. Frequency of meetings and phone calls were positively related to the formation of team cognition, while e-mail use had no effect. Gender diversity had a strong and positive effect on the development of team cognition and the effect remained stable over time. Implications for the practical potential and limitations of purposive team construction as a strategy for improving software development team performance are discussed.},
	number = {2},
	urldate = {2022-12-08},
	journal = {Journal of Management Information Systems},
	author = {He, Jun and Butler, Brian S. and King, William R.},
	month = oct,
	year = {2007},
	note = {Publisher: Routledge
\_eprint: https://doi.org/10.2753/MIS0742-1222240210},
	keywords = {expertise location, member familiarity, project teams, shared task understanding, software teams, team communications, team diversity},
	pages = {261--292},
}

@misc{amritIdentifyingCoordinationProblems2012,
	title = {Identifying {Coordination} {Problems} in {Software} {Development}: {Finding} {Mismatches} between {Software} and {Project} {Team} {Structures}},
	shorttitle = {Identifying {Coordination} {Problems} in {Software} {Development}},
	url = {http://arxiv.org/abs/1201.4142},
	doi = {10.48550/arXiv.1201.4142},
	abstract = {Today's dynamic and iterative development environment brings significant challenges for software project management. In distributed project settings, "management by walking around" is no longer an option and project managers may miss out on key project insights. The TESNA (TEchnical Social Network Analysis) method and tool aims to provide project managers both a method and a tool for gaining insights and taking corrective action. TESNA achieves this by analysing a project's evolving social and technical network structures using data from multiple sources, including CVS, email and chat repositories. Using pattern theory, TESNA helps to identify areas where the current state of the project's social and technical networks conflicts with what patterns suggest. We refer to such a conflict as a Socio-Technical Structure Clash (STSC). In this paper we report on our experience of using TESNA to identify STSCs in a corporate environment through the mining of software repositories. We find multiple instances of three STSCs (Conway's Law, Code Ownership and Project Coordination) in many of the on-going development projects, thereby validating the method and tool that we have developed.},
	urldate = {2022-12-08},
	publisher = {arXiv},
	author = {Amrit, Chintan and van Hillegersberg, Jos and Kumar, Kuldeep},
	month = jan,
	year = {2012},
	note = {arXiv:1201.4142 [cs]},
	keywords = {Computer Science - Software Engineering},
}

@article{nanJointEffectTeam2013,
	title = {Joint {Effect} of {Team} {Structure} and {Software} {Architecture} in {Open} {Source} {Software} {Development}},
	volume = {60},
	issn = {1558-0040},
	doi = {10.1109/TEM.2012.2232930},
	abstract = {In this study, we seek to understand socio-technical interactions in a system development context via an examination of the joint effect of developer team structure and open source software (OSS) architecture on OSS development performance. Using detailed data collected from code repositories from Soure-Forge.com, we find that developer team structure and software architecture significantly moderate each other's effect on OSS development performance. Larger teams tend to produce more favorable project performance when the project being developed has a high level of structural interdependency while projects with a low level of structural interdependency require smaller teams in order to achieve better project performance. Meanwhile, centralized teams tend to have a positive impact on project performance when the OSS project has a high level of structural interdependency. However, when a project has a low level of structural interdependency, centralized teams can impair project performance. This study extends our understanding of information technology's deep engagement in organizational life and provides directions for open source practitioners to better organize their projects to achieve greater performance.},
	number = {3},
	journal = {IEEE Transactions on Engineering Management},
	author = {Nan, Ning and Kumar, Sanjeev},
	month = aug,
	year = {2013},
	note = {Conference Name: IEEE Transactions on Engineering Management},
	keywords = {Collaboration, Collaboration network, Computer architecture, Context, Information processing, Joints, Software, Software architecture, open source software, social network analysis, software architecture, software project performance},
	pages = {592--603},
}

@article{manteiEffectProgrammingTeam1981,
	title = {The effect of programming team structures on programming tasks},
	volume = {24},
	issn = {0001-0782},
	url = {https://doi.org/10.1145/358568.358571},
	doi = {10.1145/358568.358571},
	abstract = {The literature recognizes two group structures for managing programming projects: Baker's chief programmer team and Weinberg's egoless team. Although each structure's success in project management can be demonstrated, this success is clearly dependent on the type of programming task undertaken. Here, for the purposes of comparison, a third project organization which lies between the other two in its communication patterns and dissemination of decision-making authority is presented. Recommendations are given for selecting one of the three team organizations depending on the task to be performed.},
	number = {3},
	urldate = {2022-12-08},
	journal = {Communications of the ACM},
	author = {Mantei, Marilyn},
	month = mar,
	year = {1981},
	keywords = {chief programmer team, group dynamics, programming team structures, project management, software engineering},
	pages = {106--113},
}

@article{sawyerSoftwareDevelopmentTeams2004,
	title = {Software development teams},
	volume = {47},
	issn = {0001-0782},
	url = {https://doi.org/10.1145/1035134.1035140},
	doi = {10.1145/1035134.1035140},
	abstract = {Considering three software development team archetypes and their implications.},
	number = {12},
	urldate = {2022-12-08},
	journal = {Communications of the ACM},
	author = {Sawyer, Steve},
	month = dec,
	year = {2004},
	pages = {95--99},
}

@misc{WhyDoesProductivity,
	title = {Why does productivity feel so good?},
	url = {https://timelyapp.com/blog/why-does-productivity-feel-so-good},
	abstract = {Everybody likes feeling productive, but what is it about being efficient and blasting through a task that we enjoy so much?},
	language = {en},
	urldate = {2022-12-07},
}

@inproceedings{tanFirstLookGood2020,
	address = {New York, NY, USA},
	series = {{ESEC}/{FSE} 2020},
	title = {A first look at good first issues on {GitHub}},
	isbn = {978-1-4503-7043-1},
	url = {https://doi.org/10.1145/3368089.3409746},
	doi = {10.1145/3368089.3409746},
	abstract = {Keeping a good influx of newcomers is critical for open source software projects' survival, while newcomers face many barriers to contributing to a project for the first time. To support newcomers onboarding, GitHub encourages projects to apply labels such as good first issue (GFI) to tag issues suitable for newcomers. However, many newcomers still fail to contribute even after many attempts, which not only reduces the enthusiasm of newcomers to contribute but makes the efforts of project members in vain. To better support the onboarding of newcomers, this paper reports a preliminary study on this mechanism from its application status, effect, problems, and best practices. By analyzing 9,368 GFIs from 816 popular GitHub projects and conducting email surveys with newcomers and project members, we obtain the following results. We find that more and more projects are applying this mechanism in the past decade, especially the popular projects. Compared to common issues, GFIs usually need more days to be solved. While some newcomers really join the projects through GFIs, almost half of GFIs are not solved by newcomers. We also discover a series of problems covering mechanism (e.g., inappropriate GFIs), project (e.g., insufficient GFIs) and newcomer (e.g., uneven skills) that makes this mechanism ineffective. We discover the practices that may address the problems, including identifying GFIs that have informative description and available support, and require limited scope and skill, etc. Newcomer onboarding is an important but challenging question in open source projects and our work enables a better understanding of GFI mechanism and its problems, as well as highlights ways in improving them.},
	urldate = {2022-12-07},
	booktitle = {Proceedings of the 28th {ACM} {Joint} {Meeting} on {European} {Software} {Engineering} {Conference} and {Symposium} on the {Foundations} of {Software} {Engineering}},
	publisher = {Association for Computing Machinery},
	author = {Tan, Xin and Zhou, Minghui and Sun, Zeyu},
	month = nov,
	year = {2020},
	keywords = {Good first issues, Newcomers, Onborading, Open Source software},
	pages = {398--409},
}

@inproceedings{miller2022did,
	title = {“{Did} you miss my comment or what?” understanding toxicity in open source discussions},
	booktitle = {In 44th international conference on software engineering ({ICSE}’22)},
	author = {Miller, Courtney and Cohen, Sophie and Klug, Daniel and Vasilescu, Bogdan and Kästner, Christian},
	year = {2022},
}

@incollection{cheriyan2017norm,
	title = {Norm violation in online communities–{A} study of {Stack} {Overflow} comments},
	booktitle = {Coordination, organizations, institutions, norms, and ethics for governance of multi-agent systems {XIII}},
	publisher = {Springer},
	author = {Cheriyan, Jithin and Savarimuthu, Bastin Tony Roy and Cranefield, Stephen},
	year = {2017},
	pages = {20--34},
}

@article{kafer2017best,
	title = {What is the best way for developers to learn new software tools? {An} empirical comparison between a text and a video tutorial},
	journal = {arXiv preprint arXiv:1704.00074},
	author = {Käfer, Verena and Kulesz, Daniel and Wagner, Stefan},
	year = {2017},
}

@inproceedings{roehm2012professional,
	title = {How do professional developers comprehend software?},
	booktitle = {2012 34th international conference on software engineering ({ICSE})},
	author = {Roehm, Tobias and Tiarks, Rebecca and Koschke, Rainer and Maalej, Walid},
	year = {2012},
	note = {tex.organization: IEEE},
	pages = {255--265},
}

@inproceedings{murphy2011peer,
	title = {Peer interaction effectively, yet infrequently, enables programmers to discover new tools},
	booktitle = {Proceedings of the {ACM} 2011 conference on {Computer} supported cooperative work},
	author = {Murphy-Hill, Emerson and Murphy, Gail C},
	year = {2011},
	pages = {405--414},
}

@article{xia2017developers,
	title = {What do developers search for on the web?},
	volume = {22},
	number = {6},
	journal = {Empirical Software Engineering},
	author = {Xia, Xin and Bao, Lingfeng and Lo, David and Kochhar, Pavneet Singh and Hassan, Ahmed E and Xing, Zhenchang},
	year = {2017},
	note = {Publisher: Springer},
	pages = {3149--3185},
}

@inproceedings{murphy2019developers,
	title = {Do developers discover new tools on the toilet?},
	booktitle = {2019 {IEEE}/{ACM} 41st international conference on software engineering ({ICSE})},
	author = {Murphy-Hill, Emerson and Smith, Edward K and Sadowski, Caitlin and Jaspan, Ciera and Winter, Collin and Jorde, Matthew and Knight, Andrea and Trenk, Andrew and Gross, Steve},
	year = {2019},
	note = {tex.organization: IEEE},
	pages = {465--475},
}

@misc{GlobalDeveloperCommunity,
	title = {The global developer community},
	url = {https://octoverse.github.com/2022/developer-community},
	abstract = {Explore the GitHub developer community and key productivity metrics.},
	language = {en-gb},
	urldate = {2022-12-06},
	journal = {The State of the Octoverse},
}

@misc{NpmBlogArchive,
	title = {npm {Blog} {Archive}: {So} long, and thanks for all the packages!},
	shorttitle = {npm {Blog} {Archive}},
	url = {https://blog.npmjs.org/post/615388323067854848/so-long-and-thanks-for-all-the-packages},
	abstract = {npm Blog (Archive); updates from the npm team are now published on the GitHub Blog and the GitHub Changelog},
	urldate = {2022-12-06},
}

@article{murphy-hillHowUsersDiscover2015,
	title = {How {Do} {Users} {Discover} {New} {Tools} in {Software} {Development} and {Beyond}?},
	volume = {24},
	issn = {0925-9724},
	url = {https://doi.org/10.1007/s10606-015-9230-9},
	doi = {10.1007/s10606-015-9230-9},
	abstract = {Software users rely on software tools such as browser tab controls and spell checkers to work effectively and efficiently, but it is difficult for users to be aware of all the tools that might be useful to them. While there are several potential technical solutions to this difficulty, we know little about social solutions, such as one user telling a peer about a tool. To explore these social solutions, we conducted two studies, an interview study and a diary study. The interview study describes a series of interviews with 18 programmers in industry to explore how tool discovery takes place. To broaden our findings to a wider group of software users, we then conducted a diary study of 76 software users in their workplaces. One finding was that social learning of software tools, while sometimes effective, is infrequent; software users appear to discover tools from peers only once every few months. We describe several implications of our findings, such as that discovery from peers can be enhanced by improving software users' ability to communicate openly and concisely about tools.},
	number = {5},
	urldate = {2022-12-03},
	journal = {Computer Supported Cooperative Work},
	author = {Murphy-Hill, Emerson and Lee, Da Young and Murphy, Gail C. and Mcgrenere, Joanna},
	month = oct,
	year = {2015},
	keywords = {Discovery, Learning, Programmers, Programming tools},
	pages = {389--422},
}

@article{kitchinKnowingGoverningCities2015,
	title = {Knowing and governing cities through urban indicators, city benchmarking and real-time dashboards},
	volume = {2},
	issn = {null},
	url = {https://doi.org/10.1080/21681376.2014.983149},
	doi = {10.1080/21681376.2014.983149},
	abstract = {Since the mid-1990s a plethora of indicator projects have been developed and adopted by cities seeking to measure and monitor various aspects of urban systems. These have been accompanied by city benchmarking endeavours that seek to compare intra- and inter-urban performance. More recently, the data underpinning such projects have started to become more open to citizens, more real-time in nature generated through sensors and locative/social media, and displayed via interactive visualisations and dashboards that can be accessed via the internet. In this paper, we examine such initiatives arguing that they advance a narrowly conceived but powerful realist epistemology – the city as visualised facts – that is reshaping how managers and citizens come to know and govern cities. We set out how and to what ends indicator, benchmarking and dashboard initiatives are being employed by cities. We argue that whilst these initiatives often seek to make urban processes and performance more transparent and to improve decision making, they are also underpinned by a naive instrumental rationality, are open to manipulation by vested interests, and suffer from often unacknowledged methodological and technical issues. Drawing on our own experience of working on indicator and dashboard projects, we argue for a conceptual re-imaging of such projects as data assemblages – complex, politically-infused, socio-technical systems that, rather than reflecting cities, actively frame and produce them.},
	number = {1},
	urldate = {2022-12-01},
	journal = {Regional Studies, Regional Science},
	author = {Kitchin, Rob and Lauriault, Tracey P. and McArdle, Gavin},
	month = jan,
	year = {2015},
	note = {Publisher: Routledge
\_eprint: https://doi.org/10.1080/21681376.2014.983149},
	keywords = {benchmarking, cities, dashboards, data assemblage, epistemology, governance, indicators, real-time},
	pages = {6--28},
}

@book{fewInformationDashboardDesign2006,
	title = {Information {Dashboard} {Design}: {The} {Effective} {Visual} {Communication} of {Data}},
	isbn = {978-0-596-10016-2},
	shorttitle = {Information {Dashboard} {Design}},
	abstract = {Dashboards have become popular in recent years as uniquely powerful tools for communicating important information at a glance. Although dashboards are potentially powerful, this potential is rarely realized. The greatest display technology in the world won't solve this if you fail to use effective visual design. And if a dashboard fails to tell you precisely what you need to know in an instant, you'll never use it, even if it's filled with cute gauges, meters, and traffic lights. Don't let your investment in dashboard technology go to waste.This book will teach you the visual design skills you need to create dashboards that communicate clearly, rapidly, and compellingly. Information Dashboard Design will explain how to:Avoid the thirteen mistakes common to dashboard designProvide viewers with the information they need quickly and clearlyApply what we now know about visual perception to the visual presentation of informationMinimize distractions, cliches, and unnecessary embellishments that create confusionOrganize business information to support meaning and usabilityCreate an aesthetically pleasing viewing experienceMaintain consistency of design to provide accurate interpretationOptimize the power of dashboard technology by pairing it with visual effectivenessStephen Few has over 20 years of experience as an IT innovator, consultant, and educator. As Principal of the consultancy Perceptual Edge, Stephen focuses on data visualization for analyzing and communicating quantitative business information. He provides consulting and training services, speaks frequently at conferences, and teaches in the MBA program at the University of California in Berkeley. He is also the author of Show Me the Numbers: Designing Tables and Graphs to Enlighten. Visit his website at www.perceptualedge.com.},
	publisher = {O'Reilly Media, Inc.},
	author = {Few, Stephen},
	year = {2006},
}

@misc{bachDashboardDesignPatterns2022,
	title = {Dashboard {Design} {Patterns}},
	url = {http://arxiv.org/abs/2205.00757},
	doi = {10.48550/arXiv.2205.00757},
	abstract = {This paper introduces design patterns for dashboards to inform dashboard design processes. Despite a growing number of public examples, case studies, and general guidelines there is surprisingly little design guidance for dashboards. Such guidance is necessary to inspire designs and discuss tradeoffs in, e.g., screenspace, interaction, or information shown. Based on a systematic review of 144 dashboards, we report on eight groups of design patterns that provide common solutions in dashboard design. We discuss combinations of these patterns in dashboard genres such as narrative, analytical, or embedded dashboard. We ran a 2-week dashboard design workshop with 23 participants of varying expertise working on their own data and dashboards. We discuss the application of patterns for the dashboard design processes, as well as general design tradeoffs and common challenges. Our work complements previous surveys and aims to support dashboard designers and researchers in co-creation, structured design decisions, as well as future user evaluations about dashboard design guidelines. Detailed pattern descriptions and workshop material can be found online: https://dashboarddesignpatterns.github.io},
	urldate = {2022-12-01},
	publisher = {arXiv},
	author = {Bach, Benjamin and Freeman, Euan and Abdul-Rahman, Alfie and Turkay, Cagatay and Khan, Saiful and Fan, Yulei and Chen, Min},
	month = aug,
	year = {2022},
	note = {arXiv:2205.00757 [cs]},
	keywords = {Computer Science - Human-Computer Interaction},
}

@book{martinAgileSoftwareDevelopment2003,
	address = {USA},
	title = {Agile {Software} {Development}: {Principles}, {Patterns}, and {Practices}},
	isbn = {978-0-13-597444-5},
	shorttitle = {Agile {Software} {Development}},
	abstract = {From the Publisher: Best selling author and world-renowned software development expert Robert C. Martin shows how to solve the most challenging problems facing software developers, project managers, and software project leaders today. This comprehensive, pragmatic tutorial on Agile Development and eXtreme programming, written by one of the founding father of Agile Development: Teaches software developers and project managers how to get projects done on time, and on budget using the power of Agile Development. Uses real-world case studies to show how to of plan, test, refactor, and pair program using eXtreme programming. Contains a wealth of reusable C++ and Java code. Focuses on solving customer oriented systems problems using UML and Design Patterns. Robert C. Martin is President of Object Mentor Inc. Martin and his team of software consultants use Object-Oriented Design, Patterns, UML, Agile Methodologies, and eXtreme Programming with worldwide clients. He is the author of the best-selling book Designing Object-Oriented C++ Applications Using the Booch Method (Prentice Hall, 1995), Chief Editor of, Pattern Languages of Program Design 3 (Addison Wesley, 1997), Editor of, More C++ Gems (Cambridge, 1999), and co-author of XP in Practice, with James Newkirk (Addison-Wesley, 2001). He was Editor in Chief of the C++ Report from 1996 to 1999. He is a featured speaker at international conferences and trade shows. Author Biography: ROBERT C. MARTIN is President of Object Mentor Inc. Martin and his team of software consultants use Object-Oriented Design, Patterns, UML, Agile Methodologies, and eXtreme Programming with worldwide clients. He is the author of the best-selling book Designing Object-Oriented C++ Applications Using the Booch Method (Prentice Hall, 1995), Chief Editor of, Pattern Languages of Program Design 3 (Addison Wesley, 1997), Editor of, More C++ Gems (Cambridge, 1999), and co-author of XP in Practice, with James Newkirk (Addison-Wesley, 2001). He was Editor in Chief of the C++ Report from 1996 to 1999. He is a featured speaker at international conferences and trade shows.},
	publisher = {Prentice Hall PTR},
	author = {Martin, Robert Cecil},
	year = {2003},
}

@incollection{trendowiczChapterFactorsInfluencing2009,
	title = {Chapter 6 {Factors} {Influencing} {Software} {Development} {Productivity}—{State}‐of‐the‐{Art} and {Industrial} {Experiences}},
	volume = {77},
	url = {https://www.sciencedirect.com/science/article/pii/S0065245809012066},
	abstract = {Managing software development productivity is a key issue in software organizations. Business demands for shorter time‐to‐market while maintaining high product quality force software organizations to look for new strategies to increase development productivity. Traditional, simple delivery rates employed to control hardware production processes have turned out not to work when simply transferred to the software domain. The productivity of software production processes may vary across development contexts dependent on numerous influencing factors. Effective productivity management requires considering these factors. Yet, there are thousands of possible factors and considering all of them would make no sense from the economical point of view. Therefore, productivity modeling should focus on a limited number of factors with the most significant impact on productivity. In this chapter, we present a comprehensive overview of productivity factors recently considered by software practitioners. The study results are based on the review of 126 publications as well as international experiences of the Fraunhofer Institute, including the most recent 13 industrial projects, four workshops, and eight surveys on software productivity. The aggregated results show that the productivity of software development processes still depends significantly on the capabilities of developers as well as on the tools and methods they use.},
	language = {en},
	urldate = {2022-11-26},
	booktitle = {Advances in {Computers}},
	publisher = {Elsevier},
	author = {Trendowicz, Adam and Münch, Jürgen},
	month = jan,
	year = {2009},
	doi = {10.1016/S0065-2458(09)01206-6},
	pages = {185--241},
}

@article{gillProductivityImpactsSoftware1990,
	title = {Productivity impacts of software complexity and developer experience},
	author = {Gill, Geoffrey K and Kemerer, Chris F},
	year = {1990},
	note = {Publisher: Cambridge, Mass.: Sloan School of Management, Massachusetts Institute of …},
}

@inproceedings{mockusSuccessionMeasuringTransfer2009,
	title = {Succession: {Measuring} transfer of code and developer productivity},
	shorttitle = {Succession},
	doi = {10.1109/ICSE.2009.5070509},
	abstract = {Code ownership transfer or succession is a crucial ingredient in open source code reuse and in offshoring projects. Measuring succession can help understand factors that affect the success of such transfers and suggest ways to make them more efficient. We propose and evaluate several methods to measure succession based on the chronology and traces of developer activities. Using ten instances of offshoring succession identified through interviews, we find that the best succession measure can accurately pinpoint the most likely mentors. We model the productivity ratio of more than 1000 developer pairs involved in the succession to test conjectures formulated using the organizational socialization theory and find the ratio to decrease for instances of offshoring and for mentors who have worked primarily on a single project or have transferred ownership for their non-primary project code, thus supporting a theory-based conjectures and providing practical suggestions on how to improve succession.},
	booktitle = {2009 {IEEE} 31st {International} {Conference} on {Software} {Engineering}},
	author = {Mockus, Audris},
	month = may,
	year = {2009},
	note = {ISSN: 1558-1225},
	keywords = {Business, Costs, Manufacturing processes, Open source software, Productivity, Programming, Testing, Virtual groups},
	pages = {67--77},
}

@inproceedings{raufPerceivedObstaclesNovice2016,
	title = {Perceived obstacles by novice developers adopting user interface {APIs} and tools},
	doi = {10.1109/VLHCC.2016.7739689},
	abstract = {An Application-Programming Interface or API provides a set of program functions that can be used to build new applications. In this paper, we study how to use the expectation-confirmation theory (ECT) to identify API usability problems, and what obstacles a novice developer faces when learning a new API and its accompanying development tools. We conduct a study over the impact of using a visual editor on API usability and then use the expectation-confirmation theory to study perceptions about the API and the editor. We finally present a list of obstacles found in the study that can be used by others to create more usable APIs and development tools.},
	booktitle = {2016 {IEEE} {Symposium} on {Visual} {Languages} and {Human}-{Centric} {Computing} ({VL}/{HCC})},
	author = {Rauf, Irum and Perälä, Pekka and Huotari, Jouni and Porres, Ivan},
	month = sep,
	year = {2016},
	note = {ISSN: 1943-6106},
	keywords = {Correlation, Electronic mail, Internet, Java, Tutorials, Usability, Visualization},
	pages = {223--227},
}

@inproceedings{begelNoviceSoftwareDevelopers2008,
	address = {New York, NY, USA},
	series = {{ICER} '08},
	title = {Novice software developers, all over again},
	isbn = {978-1-60558-216-0},
	url = {https://doi.org/10.1145/1404520.1404522},
	doi = {10.1145/1404520.1404522},
	abstract = {Transitions from novice to expert often cause stress and anxiety and require specialized instruction and support to enact efficiently. While many studies have looked at novice computer science students, very little research has been conducted on professional novices. We conducted a two-month in-situ qualitative case study of new software developers in their first six months working at Microsoft. We shadowed them in all aspects of their jobs: coding, debugging, designing, and engaging with their team, and analyzed the types of tasks in which they engage. We can explain many of the behaviors revealed by our analyses if viewed through the lens of newcomer socialization from the field of organizational man-agement. This new perspective also enables us to better understand how current computer science pedagogy prepares students for jobs in the software industry. We consider the implications of this data and analysis for developing new processes for learning in both university and industrial settings to help accelerate the transition from novice to expert software developer.},
	urldate = {2022-11-26},
	booktitle = {Proceedings of the {Fourth} international {Workshop} on {Computing} {Education} {Research}},
	publisher = {Association for Computing Machinery},
	author = {Begel, Andrew and Simon, Beth},
	month = sep,
	year = {2008},
	keywords = {computer science pedagogy, human aspects of software engineering, software development, training},
	pages = {3--14},
}

@inproceedings{chenWhyItImportant2017,
	title = {Why {Is} {It} {Important} to {Measure} {Maintainability} and {What} {Are} the {Best} {Ways} to {Do} {It}?},
	doi = {10.1109/ICSE-C.2017.75},
	abstract = {Being highly maintainable is the key to reducing approximately 75\% of most systems' life cycle costs. Software maintainability is defined as the ease with which a software system or a component can be modified, to correct faults, improve performance or other attributes, or adapt to a changed environment. There exist metrics that can help developers measure and analyze the maintainability level of a project objectively. Most of these metrics involve automated analysis of the code. In this extended abstract paper, we addressed the importance of understanding software maintainability, explored some of the best ways to measure maintainability and briefly described a comparison study we conducted between automated maintainability metrics and human-assessed maintainability metrics through a controlled experiment by performing change-request modifications on open source software (OSS) projects.},
	booktitle = {2017 {IEEE}/{ACM} 39th {International} {Conference} on {Software} {Engineering} {Companion} ({ICSE}-{C})},
	author = {Chen, Celia and Alfayez, Reem and Srisopha, Kamonphop and Boehm, Barry and Shi, Lin},
	month = may,
	year = {2017},
	keywords = {Computer bugs, Maintenance engineering, Organizations, Software, Software engineering, Software measurement},
	pages = {377--378},
}

@book{baierPrinciplesModelChecking2008,
	title = {Principles of model checking},
	publisher = {MIT Press},
	author = {Baier, C. and Katoen, J.-P.},
	year = {2008},
	keywords = {default, interim-report},
}

@inproceedings{lajiosSoftwareMetricsSuites2009,
	title = {Software metrics suites for project landscapes},
	doi = {10.1109/CSMR.2009.22},
	booktitle = {2009 13th european conference on software maintenance and reengineering},
	author = {Lajios, Georgios},
	year = {2009},
	pages = {317--318},
}

@article{turingComputableNumbersApplication1937,
	title = {On computable numbers, with an application to the {Entscheidungsproblem}},
	volume = {42},
	journal = {Proceedings of the London Mathematical Society Series 2},
	author = {Turing, Alan M.},
	year = {1937},
	keywords = {default},
	pages = {230--265},
}

@inproceedings{marzoloExtremeDevelopmentMeans2021,
	address = {Cham},
	series = {Communications in {Computer} and {Information} {Science}},
	title = {“{Extreme} {Development}” as a {Means} for {Learning} {Agile}},
	isbn = {978-3-030-93135-3},
	doi = {10.1007/978-3-030-93135-3_11},
	abstract = {During the 2020 pandemic a new modality for the capstone project in Software Engineering was introduced to our third-year students in Computer Science. They have been tasked with the development of a non trivial software product - a Twitter client capable of visual analytics - using some Agile practices, exploiting a Scrum-like process model, and using only open source tools. Due to circumstances that were either planned (in the selection of tools and requirements) or unintended (the pandemic forbade any physical meeting), the project had some interesting outcomes. The project was not easy to enact, neither for the students nor for the instructors. The main problems were two: the students were not ready to practice agile teamwork, and the open source tools they had to use were demanding and only partly suitable for the goal they were chosen for. We term this experience - where students applied an agile discipline and were required to use only open source tools - an “extreme” agile development project. This paper - written by two students together with their instructor, summarises some lessons learnt: characteristics and features of the tools and practices used, the evolution of product artifacts and some difficulties encountered, along with the solutions we adopted. An important lesson learnt is that an agile project developed by Computer Science students requires specific training in communicating correct information at the right moment, and avoiding telling “social lies” concerning the status of both the product and its development process.},
	language = {en},
	booktitle = {Frontiers in {Software} {Engineering}},
	publisher = {Springer International Publishing},
	author = {Marzolo, Paolo and Guazzaloca, Matteo and Ciancarini, Paolo},
	editor = {Succi, Giancarlo and Ciancarini, Paolo and Kruglov, Artem},
	year = {2021},
	pages = {158--175},
}

@inproceedings{ruvimovaExploratoryStudyProductivity2022,
	address = {New York, NY, USA},
	series = {{ICSE} '22},
	title = {An exploratory study of productivity perceptions in software teams},
	isbn = {978-1-4503-9221-1},
	url = {https://doi.org/10.1145/3510003.3510081},
	doi = {10.1145/3510003.3510081},
	abstract = {Software development is a collaborative process requiring a careful balance of focused individual effort and team coordination. Though questions of individual productivity have been widely examined in past literature, less is known about the interplay between developers' perceptions of their own productivity as opposed to their team's. In this paper, we present an analysis of 624 daily surveys and 2899 self-reports from 25 individuals across five software teams in North America and Europe, collected over the course of three months. We found that developers tend to operate in fluid team constructs, which impacts team awareness and complicates gauging team productivity. We also found that perceived individual productivity most strongly predicted perceived team productivity, even more than the amount of team interactions, unplanned work, and time spent in meetings. Future research should explore how fluid team structures impact individual and organizational productivity.},
	urldate = {2022-11-26},
	booktitle = {Proceedings of the 44th {International} {Conference} on {Software} {Engineering}},
	publisher = {Association for Computing Machinery},
	author = {Ruvimova, Anastasia and Lill, Alexander and Gugler, Jan and Howe, Lauren and Huang, Elaine and Murphy, Gail and Fritz, Thomas},
	month = jul,
	year = {2022},
	keywords = {productivity, software developer, team, user study},
	pages = {99--111},
}

@inproceedings{blondeauSoftwareMetricsPredict2015,
	address = {New York, NY, USA},
	series = {{IWST} '15},
	title = {Software metrics to predict the health of a project? {An} assessment in a major {IT} company},
	isbn = {978-1-4503-3857-8},
	shorttitle = {Software metrics to predict the health of a project?},
	url = {https://doi.org/10.1145/2811237.2811294},
	doi = {10.1145/2811237.2811294},
	abstract = {More and more companies would like to mine software data with the goal of assessing the health of their software projects. The hope is that some software metrics could be tracked to predict failure risks or confirm good health. If a factor of success was found, projects failures could be anticipated and early actions could be taken by the organisation to help or to monitor closely the project, allowing one to act in a preventive mode rather than a curative one. We were called by a major IT company to fulfil this goal. We conducted a study to check whether software metrics can be related to project failure. The study was both theoretic with a review of literature on the subject, and practical with mining past projects data and interviews with project managers. We found that metrics used in practice are not reliable to assess project outcome.},
	urldate = {2022-11-26},
	booktitle = {Proceedings of the {International} {Workshop} on {Smalltalk} {Technologies}},
	publisher = {Association for Computing Machinery},
	author = {Blondeau, Vincent and Anquetil, Nicolas and Ducasse, Stéphane and Cresson, Sylvain and Croisy, Pascal},
	month = jul,
	year = {2015},
	keywords = {Closed-source, Data-mining, Interviews, Project health},
	pages = {1--8},
}

@book{knuth68art,
	edition = {1st},
	title = {The art of computer programming, volume 1: {Fundamental} algorithms},
	publisher = {Addison Wesley},
	author = {Knuth, Donald E.},
	year = {1968},
	keywords = {default},
}
