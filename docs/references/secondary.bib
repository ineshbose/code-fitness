
@article{jorgensenBetterSureSafe2004,
	title = {Better sure than safe? {Over}-confidence in judgement based software development effort prediction intervals},
	volume = {70},
	issn = {0164-1212},
	shorttitle = {Better sure than safe?},
	url = {https://www.sciencedirect.com/science/article/pii/S0164121202001607},
	doi = {10.1016/S0164-1212(02)00160-7},
	abstract = {The uncertainty of a software development effort estimate can be indicated through a prediction interval (PI), i.e., the estimated minimum and maximum effort corresponding to a specific confidence level. For example, a project manager may be “90\% confident” or believe that is it “very likely” that the effort required to complete a project will be between 8000 and 12,000 work-hours. This paper describes results from four studies (Studies A–D) on human judgement (expert) based PIs of software development effort. Study A examines the accuracy of the PIs in real software projects. The results suggest that the PIs were generally much too narrow to reflect the chosen level of confidence, i.e., that there was a strong over-confidence. Studies B–D try to understand the reasons for the observed over-confidence. Study B examines the possibility that the over-confidence is related to type of experience or estimation process. Study C examines the possibility that the concept of confidence level is difficult to interpret for software estimators. Finally, Study D examines the possibility that there are unfortunate feedback mechanisms that reward over-confidence.},
	language = {en},
	number = {1},
	urldate = {2023-02-15},
	journal = {Journal of Systems and Software},
	author = {Jørgensen, Magne and Teigen, Karl Halvor and Moløkken, Kjetil},
	month = feb,
	year = {2004},
	keywords = {secondary},
	pages = {79--93},
}

@inproceedings{molokkenReviewSoftwareSurveys2003,
	title = {A review of software surveys on software effort estimation},
	doi = {10.1109/ISESE.2003.1237981},
	abstract = {This paper summarizes estimation knowledge through a review of surveys on software effort estimation. Main findings were that: (1) most projects (60-80\%) encounter effort and/or schedule overruns. The overruns, however, seem to be lower than the overruns reported by some consultancy companies. For example, Standish Group's "Chaos Report" describes an average cost overrun of 89\%, which is much higher than the average overruns found in other surveys, i.e. 3040\%. (2) The estimation methods in most frequent use of expert judgment is that there is no evidence that formal estimation models lead to more accurate estimates. (3) There is a lack of surveys including extensive analyses of the reasons for effort and schedule overruns.},
	booktitle = {2003 {International} {Symposium} on {Empirical} {Software} {Engineering}, 2003. {ISESE} 2003. {Proceedings}.},
	author = {Molokken, K. and Jorgensen, M.},
	month = sep,
	year = {2003},
	keywords = {Chaos, Computer industry, Costs, Job shop scheduling, Laboratories, Processor scheduling, Project management, Software engineering, Software performance, Writing, secondary},
	pages = {223--230},
}

@article{jorgensenReviewStudiesExpert2004,
	title = {A review of studies on expert estimation of software development effort},
	volume = {70},
	issn = {0164-1212},
	url = {https://www.sciencedirect.com/science/article/pii/S0164121202001565},
	doi = {10.1016/S0164-1212(02)00156-5},
	abstract = {This paper provides an extensive review of studies related to expert estimation of software development effort. The main goal and contribution of the review is to support the research on expert estimation, e.g., to ease other researcher’s search for relevant expert estimation studies. In addition, we provide software practitioners with useful estimation guidelines, based on the research-based knowledge of expert estimation processes. The review results suggest that expert estimation is the most frequently applied estimation strategy for software projects, that there is no substantial evidence in favour of use of estimation models, and that there are situations where we can expect expert estimates to be more accurate than formal estimation models. The following 12 expert estimation “best practice” guidelines are evaluated through the review: (1) evaluate estimation accuracy, but avoid high evaluation pressure; (2) avoid conflicting estimation goals; (3) ask the estimators to justify and criticize their estimates; (4) avoid irrelevant and unreliable estimation information; (5) use documented data from previous development tasks; (6) find estimation experts with relevant domain background and good estimation records; (7) Estimate top-down and bottom-up, independently of each other; (8) use estimation checklists; (9) combine estimates from different experts and estimation strategies; (10) assess the uncertainty of the estimate; (11) provide feedback on estimation accuracy and development task relations; and, (12) provide estimation training opportunities. We found supporting evidence for all 12 estimation principles, and provide suggestions on how to implement them in software organizations.},
	language = {en},
	number = {1},
	urldate = {2023-02-15},
	journal = {Journal of Systems and Software},
	author = {Jørgensen, M.},
	month = feb,
	year = {2004},
	keywords = {Effort estimation, Expert judgment, Project planning, Software development, secondary},
	pages = {37--60},
}

@article{boehmImprovingSoftwareProductivity1987,
	title = {Improving software productivity},
	volume = {20},
	issn = {1558-0814},
	doi = {10.1109/MC.1987.1663694},
	number = {09},
	journal = {Computer},
	author = {Boehm, B.},
	month = sep,
	year = {1987},
	note = {Place: Los Alamitos, CA, USA
Publisher: IEEE Computer Society},
	pages = {43--57},
}

@book{sommervilleSoftwareEngineering1992,
	title = {Software {Engineering}},
	isbn = {978-0-201-56529-4},
	abstract = {"Software Engineering" presents a broad perspective on software systems engineering, concentrating on widely-used techniques for developing large-scale software systems. This best-selling book covers a wide spectrum of software processes from initial requirements elicitation through design and development to system evolution. It supports students taking undergraduate and graduate courses in software engineering. The sixth edition has been restructured and updated, important new topics have been added and obsolete material has been cut. Reuse now focuses on component-based development and patterns; object-oriented design has a process focus and uses the UML; the chapters on requirements have been split to cover the requirements themselves and requirements engineering process; cost estimation has been updated to include the COCOMO 2 model.},
	language = {en},
	publisher = {Addison-Wesley},
	author = {Sommerville, Ian},
	year = {1992},
	note = {Google-Books-ID: DoJQAAAAMAAJ},
}

@book{pressmanSoftwareEngineering3rd1992,
	address = {USA},
	title = {Software engineering (3rd ed.): a practitioner's approach},
	isbn = {978-0-07-050814-9},
	shorttitle = {Software engineering (3rd ed.)},
	publisher = {McGraw-Hill, Inc.},
	author = {Pressman, Roger S.},
	year = {1992},
}

@article{computerstaffSoftwareMetricsGood1994,
	title = {Software {Metrics}: {Good}, {Bad} and {Missing}},
	volume = {27},
	issn = {0018-9162},
	shorttitle = {Software {Metrics}},
	url = {https://doi.org/10.1109/2.312055},
	doi = {10.1109/2.312055},
	abstract = {The software industry is an embarrassment when it comes to measurement and metrics. Many software managers and practitioners, including tenured academics in software engineering and computer science, seem to know little or nothing about these topics. Many of the measurements found in the software literature are not used with enough precision to replicate the author's findings-a canon of scientific writing in other fields. Several of the most widely used software metrics have been proved unworkable, yet they continue to show up in books, encyclopedias, and refereed journals. So long as these invalid metrics are used carelessly, there can be no true software engineering, only a kind of amateurish craft that uses rough approximations instead of precise measurement. The paper considers three significant and widely used software metrics that are invalid under various conditions: lines of code or LOC metrics, software science or Halstead metrics, and the cost-per-defect metric. Fortunately, two metrics that actually generate useful information-complexity metrics and function-point metrics-are growing in use and importance.},
	number = {9},
	urldate = {2022-12-12},
	journal = {Computer},
	author = {Jones, C},
	month = sep,
	year = {1994},
	pages = {98--100},
}

@article{cookeMeasuringTeamKnowledge2001,
	title = {Measuring {Team} {Knowledge} {During} {Skill} {Acquisition} of a {Complex} {Task}},
	volume = {5},
	issn = {1088-6362},
	url = {https://doi.org/10.1207/S15327566IJCE0503_10},
	doi = {10.1207/S15327566IJCE0503_10},
	abstract = {The design of team training programs and other team interventions could benefit from an understanding of team cognition. The research presented in this article evaluates methods for eliciting and assessing team knowledge during acquisition of a complex task. Knowledge measures are evaluated in terms of their ability to predict team performance and also in terms of how they reflect skill acquisition. The study was conducted in the context of a synthetic 3-person team task that involved operating an uninhabited air vehicle (UAV). Eleven teams of 3 Air Force ROTC cadets participated in 3 experimental sessions lasting from 3 to 6 hr. During these sessions, teams were trained on the task and were observed as they performed ten 40-min missions. During the missions, team performance and team process behaviors were measured, as well as the fleeting team knowledge associated with situation awareness. In addition, long-term team knowledge regarding both taskwork and teamwork were measured offline in four sessions. Results indicated that teams reached asymptotic performance on this task after 1.5 hr of individual training and four 40-min team missions. This skill acquisition was paralleled by improvements in team situation models, teamwork knowledge, and, to a lesser extent, team process behaviors. Taskwork relatedness ratings measured at both the individual and team level were good predictors of team performance and indicated that high performing teams had more knowledge of the task from the perspective of other team members, as opposed to lower performing teams. These measures help reveal the knowledge underlying team behavior and thus have implications for team training and other interventions.},
	number = {3},
	urldate = {2022-12-12},
	journal = {International Journal of Cognitive Ergonomics},
	author = {Cooke, Nancy J. and Kiekel, Preston A. and Helm, Erin E.},
	month = sep,
	year = {2001},
	note = {Publisher: Routledge},
	pages = {297--315},
}

@article{holmstromAgilePracticesReduce2006,
	title = {Agile {Practices} {Reduce} {Distance} in {Global} {Software} {Development}},
	volume = {23},
	issn = {1058-0530},
	url = {https://doi.org/10.1201/1078.10580530/46108.23.3.20060601/93703.2},
	doi = {10.1201/1078.10580530/46108.23.3.20060601/93703.2},
	abstract = {This article explores how agile practices can reduce three kinds of “distance” – temporal, geographical, and sociocultural – in global software development (GSD). On the basis of two in-depth case studies, specific Scrum and eXtreme Programming (XP) practices are found to be useful for reducing communication, coordination, and control problems that have been associated with GSD.},
	number = {3},
	urldate = {2022-12-12},
	journal = {Information Systems Management},
	author = {Holmström, Helena and Fitzgerald, Brian and Ågerfalk, Pär J. and Conchúir, Eoin Ó.},
	month = jun,
	year = {2006},
	note = {Publisher: Taylor \& Francis},
	pages = {7--18},
}

@article{brodbeckCommunicationPerformanceSoftware2001,
	title = {Communication and performance in software development projects},
	volume = {10},
	issn = {1359-432X},
	url = {https://doi.org/10.1080/13594320042000043},
	doi = {10.1080/13594320042000043},
	abstract = {A study of 21 software development (SD) project groups using data from 170 participants holding different positions (engineers, user representatives, project managers) and a quasi-longitudinal design shows that user participation inhibits, and standardization of methods and tools facilitates, effective SD project performance. Over and above these effects, hierarchical regression analysis reveals taskrelated internal communication to predict performance positively. Moderated regression analysis reveals that high communication facilitates project performance more strongly in late stages of the project life-cycle and when standardization of methods and tools is low. Implications for facilitating SD projects' functioning, for future research and theory building, are discussed.},
	number = {1},
	urldate = {2022-12-12},
	journal = {European Journal of Work and Organizational Psychology},
	author = {Brodbeck, Felix C.},
	month = mar,
	year = {2001},
	note = {Publisher: Routledge},
	pages = {73--94},
}

@article{alexanderUsabilityPrintOnline2013,
	title = {The {Usability} of {Print} and {Online} {Video} {Instructions}},
	volume = {22},
	issn = {1057-2252},
	url = {https://doi.org/10.1080/10572252.2013.775628},
	doi = {10.1080/10572252.2013.775628},
	abstract = {This study investigates the usability of print and online video instructions for computer tasks. Usability tests, comprehension tests, and questionnaires were collected from participants, and 4 areas of usability were analyzed: effectiveness, retention, satisfaction, and preference. Findings show marginal differences between the 2 mediums, except in terms of user satisfaction and instruction length. This research helps technical communicators better understand the affordances, or potentials and limitations, of print and video instructions.},
	number = {3},
	urldate = {2022-12-12},
	journal = {Technical Communication Quarterly},
	author = {Alexander, Kara   Poe},
	month = jul,
	year = {2013},
	note = {Publisher: Routledge},
	keywords = {affordances, print instructions, technical communication, usability, user satisfaction, video instructions},
	pages = {237--259},
}

@article{deomeloInterpretativeCaseStudies2013,
	title = {Interpretative case studies on agile team productivity and management},
	volume = {55},
	issn = {0950-5849},
	url = {https://doi.org/10.1016/j.infsof.2012.09.004},
	doi = {10.1016/j.infsof.2012.09.004},
	abstract = {Context: The management of software development productivity is a key issue in software organizations, where the major drivers are lower cost and shorter time-to-market. Agile methods, including Extreme Programming and Scrum, have evolved as ''light'' approaches that simplify the software development process, potentially leading to increased team productivity. However, little empirical research has examined which factors do have an impact on productivity and in what way, when using agile methods. Objective: Our objective is to provide a better understanding of the factors and mediators that impact agile team productivity. Method: We have conducted a multiple-case study for 6months in three large Brazilian companies that have been using agile methods for over 2years. We have focused on the main productivity factors perceived by team members through interviews, documentation from retrospectives, and non-participant observation. Results: We developed a novel conceptual framework, using thematic analysis to understand the possible mechanisms behind such productivity factors. Agile team management was found to be the most influential factor in achieving agile team productivity. At the intra-team level, the main productivity factors were team design (structure and work allocation) and member turnover. At the inter-team level, the main productivity factors were how well teams could be effectively coordinated by proper interfaces and other dependencies and avoiding delays in providing promised software to dependent teams. Conclusion: Teams should be aware of the influence and magnitude of turnover, which has been shown negative for agile team productivity. Team design choices remain an important factor impacting team productivity, even more pronounced on agile teams that rely on teamwork and people factors. The intra-team coordination processes must be adjusted to enable productive work by considering priorities and pace between teams. Finally, the revised conceptual framework for agile team productivity supports further tests through confirmatory studies.},
	number = {2},
	urldate = {2022-12-12},
	journal = {Information and Software Technology},
	author = {De O. Melo, Claudia and S. Cruzes, Daniela and Kon, Fabio and Conradi, Reidar},
	month = feb,
	year = {2013},
	keywords = {Agile software development, Industrial case studies, Team management, Team productivity factors, Thematic analysis},
	pages = {412--427},
}

@article{basili1979investigation,
	title = {An investigation of human factors in software development.},
	volume = {12},
	number = {12},
	journal = {Computer},
	author = {Basili, Victor R and Reiter Jr, Robert W},
	year = {1979},
	pages = {21--38},
}

@book{weinbergPsychologyComputerProgramming1988,
	address = {USA},
	title = {The psychology of computer programming},
	isbn = {0-442-20764-6},
	publisher = {Van Nostrand Reinhold Co.},
	author = {Weinberg, G. M.},
	year = {1988},
}

@article{mills1971chief,
	title = {Chief programmer teams: {Principles} and procedures ({IBM} {Rep}. {FSC} 71-5108)},
	journal = {Gaithersburg, MD: IBM Federal Systems Division},
	author = {Mills, HD},
	year = {1971},
}

@article{bakerChiefProgrammerTeam1972,
	title = {Chief programmer team management of production programming},
	volume = {11},
	issn = {0018-8670},
	doi = {10.1147/sj.111.0056},
	abstract = {Production programming projects today are often staffed by relatively junior programmers with at most a few years of experience. This condition is primarily the result of the rapid development of the computer and the burgeoning of its applications. Although understandable, such staffing has at least two negative effects on the costs of projects. First, the low average level of experience and knowledge frequently results in less-than-optimum efficiency in programming design, coding, and testing. Concurrently, the more experienced programmers, who have both the insight and knowledge needed to improve this situation, are frequently in second- or third-level management positions where they cannot effectively or economically do the required detailed work of programming.},
	number = {1},
	journal = {IBM Systems Journal},
	author = {Baker, F. T.},
	year = {1972},
	note = {Conference Name: IBM Systems Journal},
	pages = {56--73},
}

@article{walzSoftwareDesignTeam1993,
	title = {Inside a software design team: knowledge acquisition, sharing, and integration},
	volume = {36},
	issn = {0001-0782},
	shorttitle = {Inside a software design team},
	url = {https://doi.org/10.1145/163430.163447},
	doi = {10.1145/163430.163447},
	number = {10},
	urldate = {2022-12-12},
	journal = {Communications of the ACM},
	author = {Walz, Diane B. and Elam, Joyce J. and Curtis, Bill},
	month = oct,
	year = {1993},
	keywords = {case study, empirical studies of software development, requirements determination, software design teams, software management},
	pages = {63--77},
}

@article{farajCoordinatingExpertiseSoftware2000,
	title = {Coordinating {Expertise} in {Software} {Development} {Teams}},
	volume = {46},
	issn = {0025-1909},
	url = {https://pubsonline.informs.org/doi/abs/10.1287/mnsc.46.12.1554.12072},
	doi = {10.1287/mnsc.46.12.1554.12072},
	abstract = {Like all teams, knowledge teams must acquire and manage critical resources in order to accomplish their work. The most critical resource for knowledge teams is expertise, or specialized skills and knowledge, but the mere presence of expertise on a team is insufficient to produce high-quality work. Expertise must be managed and coordinated in order to leverage its potential. That is, teams must be able to manage their skill and knowledge interdependencies effectively through expertise coordination, which entails knowing where expertise is located, knowing where expertise is needed, and bringing needed expertise to bear. This study investigates the importance of expertise coordination through a cross-sectional investigation of 69 software development teams. The analysis reveals that expertise coordination shows a strong relationship with team performance that remains significant over and above team input characteristics, presence of expertise, and administrative coordination.},
	number = {12},
	urldate = {2022-12-12},
	journal = {Management Science},
	author = {Faraj, Samer and Sproull, Lee},
	month = dec,
	year = {2000},
	note = {Publisher: INFORMS},
	keywords = {distributed cognition, expertise coordination, software development, team performance, team processes},
	pages = {1554--1568},
}

@article{lewisMeasuringTransactiveMemory2003,
	title = {Measuring transactive memory systems in the field: {Scale} development and validation},
	volume = {88},
	issn = {1939-1854},
	shorttitle = {Measuring transactive memory systems in the field},
	doi = {10.1037/0021-9010.88.4.587},
	abstract = {This study describes the development and validity testing of a field measure of transactive memory systems. Transactive memory systems are especially important for teams designed to leverage members' expertise, but field research has lagged because there are no adequate measures of the construct. The author developed and tested a 15-item scale in a laboratory sample of 124 teams, a field sample of 64 Master of Business Administration consulting teams, and a field sample of 27 teams from technology companies. Results from the present study demonstrate that the scale is internally consistent, related to alternative measures and hypothesized causes and effects, and unrelated to theoretically distinct constructs, providing evidence of convergent, criterion-related, and discriminant validity. Suggestions for improving the scale, future validity testing, and possible boundary conditions are discussed. (PsycINFO Database Record (c) 2016 APA, all rights reserved)},
	journal = {Journal of Applied Psychology},
	author = {Lewis, Kyle},
	year = {2003},
	note = {Place: US
Publisher: American Psychological Association},
	keywords = {Cognitive Assessment, Human Information Storage, Memory, Test Construction, Test Validity},
	pages = {587--604},
}

@article{curtisFieldStudySoftware1988,
	title = {A field study of the software design process for large systems},
	volume = {31},
	issn = {0001-0782},
	url = {https://doi.org/10.1145/50087.50089},
	doi = {10.1145/50087.50089},
	abstract = {The problems of designing large software systems were studied through interviewing personnel from 17 large projects. A layered behavioral model is used to analyze how three of these problems—the thin spread of application domain knowledge, fluctuating and conflicting requirements, and communication bottlenecks and breakdowns—affected software productivity and quality through their impact on cognitive, social, and organizational processes.},
	number = {11},
	urldate = {2022-12-12},
	journal = {Communications of the ACM},
	author = {Curtis, Bill and Krasner, Herb and Iscoe, Neil},
	month = nov,
	year = {1988},
	pages = {1268--1287},
}

@article{crowstonCoordinationTheoryApproach1997,
	title = {A {Coordination} {Theory} {Approach} to {Organizational} {Process} {Design}},
	volume = {8},
	issn = {1047-7039},
	url = {https://pubsonline.informs.org/doi/abs/10.1287/orsc.8.2.157},
	doi = {10.1287/orsc.8.2.157},
	abstract = {An important practical problem for many managers is finding alternative processes for performing a desired task, for example, one that is more efficient, cheaper, or that is automated or enhanced by the use of information technology. Improving processes also poses theoretical challenges. Coordination theory provides an approach to the study of processes. In this view, the design of a process depends on the coordination mechanisms chosen to manage dependencies among tasks and resources involved in the process.

In this paper, I use coordination theory to analyze the software change process of a large mini-computer manufacturer. Mechanisms analyzed include those for task assignment, resource sharing, and managing dependencies between modules of source code. For each, I suggest alternative mechanisms and thus alternative designs for the process. The organization assigned problem reports to engineers based on the module that appeared to be in error, since engineers only worked on particular modules. Alternative task assignment mechanisms include assignment to engineers based on workload or market-like bids. Modules of source code were not shared, but rather “owned” by one engineer, thus reducing the need for coordination. An alternative resource sharing mechanism would be needed to manage source code if multiple engineers could work on the same modules. Finally, engineers managed dependencies between modules informally, relying on their personal knowledge of which other engineers used their code; alternatives include formally defining the interfaces between modules and tracking their users.

Software bug fixing provides a microcosm of coordination problems and solutions. Similar coordination problems arise in most processes and are managed by a similar range of mechanisms. For example, diagnosing bug reports and assigning them to engineers may have interesting parallels to diagnosing patients and assigning them to specialists.

While the case presented does not formally test coordination theory, it does illustrate the potential of coordination theory for exploring the space of organizational processes. Future work includes developing more rigorous techniques for such analyses, applying the techniques to a broader range of processes, identifying additional coordination problems and mechanisms and developing tools for collecting and comparing processes and automatically suggesting potential alternatives.},
	number = {2},
	urldate = {2022-12-12},
	journal = {Organization Science},
	author = {Crowston, Kevin},
	month = apr,
	year = {1997},
	note = {Publisher: INFORMS},
	keywords = {coordination theory, organization theory, organizational processes, process redesign, process reengineering},
	pages = {157--175},
}

@article{krautCoordinationSoftwareDevelopment1995,
	title = {Coordination in software development},
	volume = {38},
	issn = {0001-0782},
	url = {https://doi.org/10.1145/203330.203345},
	doi = {10.1145/203330.203345},
	abstract = {Since its inception, the software industry has been in crisis. As Blazer noted 20 years ago, “[Software] is unreliable, delivered late, unresponsive to change, inefficient, and expensive … and has been for the past 20 years” [4]. In a survey of software contractors and government contract officers, over half of the respondents believed that calendar overruns, cost overruns, code that required in-house modifications before being usable, and code that was difficult to modify were common problems in the software projects they supervised [22]. Even today, problems with software systems are common and highly-publicized occurrences.},
	number = {3},
	urldate = {2022-12-12},
	journal = {Communications of the ACM},
	author = {Kraut, Robert E. and Streeter, Lynn A.},
	month = mar,
	year = {1995},
	pages = {69--81},
}

@article{kemererEmpiricalValidationSoftware1987,
	title = {An empirical validation of software cost estimation models},
	volume = {30},
	issn = {0001-0782},
	url = {https://doi.org/10.1145/22899.22906},
	doi = {10.1145/22899.22906},
	abstract = {Practitioners have expressed concern over their inability to accurately estimate costs associated with software development. This concern has become even more pressing as costs associated with development continue to increase. As a result, considerable research attention is now directed at gaining a better understanding of the software-development process as well as constructing and evaluating software cost estimating tools. This paper evaluates four of the most popular algorithmic models used to estimate software costs (SLIM, COCOMO, Function Points, and ESTIMACS). Data on 15 large completed business data-processing projects were collected and used to test the accuracy of the models' ex post effort estimation. One important result was that Albrecht's Function Points effort estimation model was validated by the independent data provided in this study [3]. The models not developed in business data-processing environments showed significant need for calibration. As models of the software-development process, all of the models tested failed to sufficiently reflect the underlying factors affecting productivity. Further research will be required to develop understanding in this area.},
	number = {5},
	urldate = {2022-12-12},
	journal = {Communications of the ACM},
	author = {Kemerer, Chris F},
	month = may,
	year = {1987},
	pages = {416--429},
}

@article{briand2002software,
	title = {Software resource estimation},
	volume = {2},
	number = {PZ},
	journal = {Encyclopedia of Software engineering},
	author = {Briand, Lionel C and Wieczorek, Isabella},
	year = {2002},
	note = {Publisher: John Wiley \& Sons},
	pages = {1160--1196},
}

@article{abdel-hamidSlipperyPathProductivity1996,
	title = {The slippery path to productivity improvement},
	volume = {13},
	issn = {1937-4194},
	doi = {10.1109/52.526831},
	abstract = {Productivity tools simply aren't delivering increased productivity even when a project is managed "by the book". It is demonstrated that there may be more systemic, albeit counterintuitive, causes for the "productivity paradox". Specifically, the productivity potential of software engineering tools may be squandered not because organizations fail to institute the necessary managerial practices but because the software development environment is a complex social system that causes such practices to have unintended consequences. To support this view, the author uses a system dynamics microworld of the software development process to simulate the long term productivity trend in a a hypothetical project environment managed "by-the-book". The microworld lets the project team examine possible causes one by one through controlled experimentation and hence allows them to discern true causal relationships in a failed project. The results indicate productivity erosion was unintentionally accelerated by perfectly "good" planning and control practices.},
	number = {4},
	journal = {IEEE Software},
	author = {Abdel-Hamid, T.K.},
	month = jul,
	year = {1996},
	note = {Conference Name: IEEE Software},
	keywords = {Application software, Chemical technology, Computer aided software engineering, Feedback, Laboratories, Productivity, Programming, Project management, Software development management, Technology management},
	pages = {43--52},
}

@article{herron2005identifying,
	title = {Identifying your organization’s best practices},
	journal = {Crosstalk (June 2005)},
	author = {Herron, David and Garmus, David},
	year = {2005},
}

@inproceedings{morisioFrameworkBasedSoftware1999,
	title = {Framework based software development: investigating the learning effect},
	shorttitle = {Framework based software development},
	doi = {10.1109/METRIC.1999.809747},
	abstract = {We present a case study in framework based software development, with specific analysis of the effect of learning on productivity and defect density. The framework supports the development of multimedia, web-based services on a digital network. It uses a CORBA infrastructure, is developed in Java, and integrates COTS (Component-Off-The-Shelf). The case study considers the development of the framework and the development of a number of applications reusing the framework. Some of the applications are also developed without the framework. The study uses a nested factors experimental design, and measures effort, application size, defects, productivity, reuse level. The main result of the study is the correlation found between framework learning and productivity increase; and between framework learning and defect density decrease. We also underline an impressive difference in productivity between traditional development, development of the framework and development with the framework.},
	booktitle = {Proceedings {Sixth} {International} {Software} {Metrics} {Symposium} ({Cat}. {No}.{PR00403})},
	author = {Morisio, M. and Romano, D. and Moiso, C.},
	month = nov,
	year = {1999},
	keywords = {Decision support systems, Programming},
	pages = {260--268},
}

@article{teasleyRapidSoftwareDevelopment2002,
	title = {Rapid software development through team collocation},
	volume = {28},
	issn = {1939-3520},
	doi = {10.1109/TSE.2002.1019481},
	abstract = {In a field study conducted at a leading Fortune 100 company, we examined how having development teams reside in their own large room (an arrangement called radical collocation) affected system development. The collocated projects had significantly higher productivity and shorter schedules than both the industry benchmarks and the performance of past similar projects within the firm. The teams reported high satisfaction about their process, and both customers and project sponsors were similarly highly satisfied. The analysis of questionnaire, interview and observational data from these teams showed that being "at hand," i.e. both visible and available, helped them to coordinate their work better and learn from each other. Radical collocation seems to be one of the factors leading to high productivity in these teams.},
	number = {7},
	journal = {IEEE Transactions on Software Engineering},
	author = {Teasley, S.D. and Covi, L.A. and Krishnan, M.S. and Olson, J.S.},
	month = jul,
	year = {2002},
	note = {Conference Name: IEEE Transactions on Software Engineering},
	keywords = {Application software, Computer Society, Costs, Job shop scheduling, Processor scheduling, Productivity, Programming, Quality management, Software engineering, Software quality},
	pages = {671--683},
}

@article{careyImpactCommunicationMode1997,
	title = {The impact of communication mode and task complexity on small group performance and member satisfaction},
	volume = {13},
	issn = {0747-5632},
	url = {https://www.sciencedirect.com/science/article/pii/S0747563296000271},
	doi = {10.1016/S0747-5632(96)00027-1},
	abstract = {Software technology in the form of decision and group support systems has been deployed in many work environments. In some cases, these technologies are installed and used with little understanding of how this genre of software impacts upon group work. It often is presumed that productivity of a group will increase; however, upon further investigation, this may not be the case. The current study examines the impact of technology on a number of factors including time to complete task, member satisfaction, perceived information load, the number of contributing transactions, and task complexity.},
	language = {en},
	number = {1},
	urldate = {2022-12-12},
	journal = {Computers in Human Behavior},
	author = {Carey, Jane M. and Kacmar, Charles J.},
	month = jan,
	year = {1997},
	pages = {23--49},
}

@article{khanMoodsAffectProgrammers2011,
	title = {Do moods affect programmers’ debug performance?},
	volume = {13},
	issn = {1435-5558},
	url = {https://doi.org/10.1007/s10111-010-0164-1},
	doi = {10.1007/s10111-010-0164-1},
	abstract = {There is much research that shows people’s mood can affect their activities. This paper argues that this also applies to programmers, especially their debugging. Literature-based framework is presented linking programming with various cognitive activities as well as linking cognitive activities with moods. Further, the effect of mood on debugging was tested in two experiments. In the first experiment, programmers (n = 72) saw short movie clips selected for their ability to provoke specific moods. Afterward, they completed a debugging test. Results showed the video clips had a significant effect on programmers’ debugging performance; especially, there was a significant difference after watching low- and high-arousal-evoking video clips. In the second experiment, programmers’ mood was manipulated by asking participants (n = 19) to dry run algorithms for at least 16 min. They performed some physical exercises before continuing dry running algorithms again. The results showed a significant increase in arousal and valence that coincided with an improvement in programmers’ task performance after the physical exercises. Together, this suggests that programmers’ moods influence some programming tasks such as debugging.},
	number = {4},
	urldate = {2022-12-12},
	journal = {Cognition, Technology and Work},
	author = {Khan, Iftikhar Ahmed and Brinkman, Willem-Paul and Hierons, Robert M.},
	month = nov,
	year = {2011},
	keywords = {Coding and debugging, Emotions, Moods, Performance, Programmers},
	pages = {245--258},
}

@inproceedings{mullerStuckFrustratedFlow2015,
	title = {Stuck and {Frustrated} or in {Flow} and {Happy}: {Sensing} {Developers}' {Emotions} and {Progress}},
	volume = {1},
	shorttitle = {Stuck and {Frustrated} or in {Flow} and {Happy}},
	doi = {10.1109/ICSE.2015.334},
	abstract = {Software developers working on change tasks commonly experience a broad range of emotions, ranging from happiness all the way to frustration and anger. Research, primarily in psychology, has shown that for certain kinds of tasks, emotions correlate with progress and that biometric measures, such as electro-dermal activity and electroencephalography data, might be used to distinguish between emotions. In our research, we are building on this work and investigate developers' emotions, progress and the use of biometric measures to classify them in the context of software change tasks. We conducted a lab study with 17 participants working on two change tasks each. Participants were wearing three biometric sensors and had to periodically assess their emotions and progress. The results show that the wide range of emotions experienced by developers is correlated with their perceived progress on the change tasks. Our analysis also shows that we can build a classifier to distinguish between positive and negative emotions in 71.36\% and between low and high progress in 67.70\% of all cases. These results open up opportunities for improving a developer's productivity. For instance, one could use such a classifier for providing recommendations at opportune moments when a developer is stuck and making no progress.},
	booktitle = {2015 {IEEE}/{ACM} 37th {IEEE} {International} {Conference} on {Software} {Engineering}},
	author = {Müller, Sebastian C. and Fritz, Thomas},
	month = may,
	year = {2015},
	note = {ISSN: 1558-1225},
	keywords = {Atmospheric measurements, Biosensors, Electroencephalography, Particle measurements, Psychology, Software, Software engineering},
	pages = {688--699},
}

@article{graziotinFeelingsMatterCorrelation2015,
	title = {Do feelings matter? {On} the correlation of affects and the self-assessed productivity in software engineering},
	volume = {27},
	issn = {2047-7473},
	shorttitle = {Do feelings matter?},
	url = {https://doi.org/10.1002/smr.1673},
	doi = {10.1002/smr.1673},
	number = {7},
	urldate = {2022-12-12},
	journal = {Journal of Software: Evolution and Process},
	author = {Graziotin, Daniel and Wang, Xiaofeng and Abrahamsson, Pekka},
	month = jul,
	year = {2015},
	keywords = {affects, emotions, empirical software engineering, feelings, moods, psychological measurements},
	pages = {467--487},
}

@article{beechamMotivationSoftwareEngineering2008,
	title = {Motivation in {Software} {Engineering}: {A} systematic literature review},
	volume = {50},
	issn = {0950-5849},
	shorttitle = {Motivation in {Software} {Engineering}},
	url = {https://doi.org/10.1016/j.infsof.2007.09.004},
	doi = {10.1016/j.infsof.2007.09.004},
	abstract = {Objective: In this paper, we present a systematic literature review of motivation in Software Engineering. The objective of this review is to plot the landscape of current reported knowledge in terms of what motivates developers, what de-motivates them and how existing models address motivation. Methods: We perform a systematic literature review of peer reviewed published studies that focus on motivation in Software Engineering. Systematic reviews are well established in medical research and are used to systematically analyse the literature addressing specific research questions. Results: We found 92 papers related to motivation in Software Engineering. Fifty-six percent of the studies reported that Software Engineers are distinguishable from other occupational groups. Our findings suggest that Software Engineers are likely to be motivated according to three related factors: their 'characteristics' (for example, their need for variety); internal 'controls' (for example, their personality) and external 'moderators' (for example, their career stage). The literature indicates that de-motivated engineers may leave the organisation or take more sick-leave, while motivated engineers will increase their productivity and remain longer in the organisation. Aspects of the job that motivate Software Engineers include problem solving, working to benefit others and technical challenge. Our key finding is that the published models of motivation in Software Engineering are disparate and do not reflect the complex needs of Software Engineers in their career stages, cultural and environmental settings. Conclusions: The literature on motivation in Software Engineering presents a conflicting and partial picture of the area. It is clear that motivation is context dependent and varies from one engineer to another. The most commonly cited motivator is the job itself, yet we found very little work on what it is about that job that Software Engineers find motivating. Furthermore, surveys are often aimed at how Software Engineers feel about 'the organisation', rather than 'the profession'. Although models of motivation in Software Engineering are reported in the literature, they do not account for the changing roles and environment in which Software Engineers operate. Overall, our findings indicate that there is no clear understanding of the Software Engineers' job, what motivates Software Engineers, how they are motivated, or the outcome and benefits of motivating Software Engineers.},
	number = {9-10},
	urldate = {2022-12-12},
	journal = {Information and Software Technology},
	author = {Beecham, Sarah and Baddoo, Nathan and Hall, Tracy and Robinson, Hugh and Sharp, Helen},
	month = aug,
	year = {2008},
	keywords = {Characteristics, Motivation, Personality, Software Engineer, Software Engineering, Systematic literature review},
	pages = {860--878},
}

@incollection{koIndividualTeamOrganization2019,
	address = {Berkeley, CA},
	title = {Individual, {Team}, {Organization}, and {Market}: {Four} {Lenses} of {Productivity}},
	isbn = {978-1-4842-4221-6},
	shorttitle = {Individual, {Team}, {Organization}, and {Market}},
	url = {https://doi.org/10.1007/978-1-4842-4221-6_6},
	abstract = {When we think about productivity in software development, it’s reasonable to start with a basic concept of work per unit of effort. The more work a developer accomplishes with their efforts, the better.},
	language = {en},
	urldate = {2022-12-12},
	booktitle = {Rethinking {Productivity} in {Software} {Engineering}},
	publisher = {Apress},
	author = {Ko, Amy J.},
	editor = {Sadowski, Caitlin and Zimmermann, Thomas},
	year = {2019},
	doi = {10.1007/978-1-4842-4221-6_6},
	pages = {49--55},
}

@article{yilmazEffectiveSocialProductivity2016,
	title = {Effective {Social} {Productivity} {Measurements} during {Software} {Development} — {An} {Empirical} {Study}},
	volume = {26},
	issn = {0218-1940},
	url = {https://www.worldscientific.com/doi/abs/10.1142/S0218194016500194},
	doi = {10.1142/S0218194016500194},
	abstract = {Much of contemporary scientific discussion regarding factors that influence software development productivity is undertaken in various domains where there is an insufficient empirical basis for exploring socio-technical factors of productivity that are specific to a software development organization. The purpose of the study is to characterize the multidimensional nature of software development productivity and its social aspects as a set of latent constructs (i.e. variables that are not directly observed) for a medium-sized software company. To this end, we designed an exploratory in-depth field study based on the hypothesized productivity constructs, which were modeled by a set of factors identified from literature reviews, and later refined by industrial focus groups. In order to demonstrate the applicability of our approach, we conducted confirmatory factor analysis with the data attained from a questionnaire with 216 participants. To investigate factors of influence further, we analyzed the impact of selected team-based variables over the latent constructs of productivity. Taken together, our findings confirm that such an approach can be used to explore the quantifiable influence of socio-technical factors that would affect productivity of a particular software development organization. Ultimately, the resulting model provides guidance to explore the comparative importance of a set of firm-specific factors that may help to improve the productivity of the organization.},
	number = {03},
	urldate = {2022-12-12},
	journal = {International Journal of Software Engineering and Knowledge Engineering},
	author = {Yilmaz, Murat and O'Connor, Rory V. and Clarke, Paul},
	month = apr,
	year = {2016},
	note = {Publisher: World Scientific Publishing Co.},
	keywords = {Structure equation modeling, productivity factors of software development, socio-technical aspects of software development},
	pages = {457--490},
}

@misc{wagnerSystematicReviewProductivity2018,
	title = {A {Systematic} {Review} of {Productivity} {Factors} in {Software} {Development}},
	url = {http://arxiv.org/abs/1801.06475},
	doi = {10.48550/arXiv.1801.06475},
	abstract = {Analysing and improving productivity has been one of the main goals of software engineering research since its beginnings. A plethora of studies has been conducted on various factors that resulted in several models for analysis and prediction of productivity. However, productivity is still an issue in current software development and not all factors and their relationships are known. This paper reviews the large body of available literature in order to distill a list of the main factors influencing productivity investigated so far. The measure for importance here is the number of articles a factor is mentioned in. Special consideration is given to soft or human-related factors in software engineering that are often not analysed with equal detail as more technical factors. The resulting list can be used to guide further analysis and as basis for building productivity models.},
	urldate = {2022-12-12},
	publisher = {arXiv},
	author = {Wagner, Stefan and Ruhe, Melanie},
	month = jan,
	year = {2018},
	note = {arXiv:1801.06475 [cs]},
	keywords = {Computer Science - Software Engineering},
}

@article{clincySoftwareDevelopmentProductivity2003,
	title = {Software development productivity and cycle time reduction},
	volume = {19},
	issn = {1937-4771},
	abstract = {Increasing software developers' productivity and reducing the software development process' cycle time are key goals for organizations responsible for building software applications. This paper proposes four major areas impacting an organization's ability to increase developer productivity and reduce development cycle time. The four areas are (1) organizational structure and climate, (2) reward system, (3) software development process and (4) the use of software design and testing tools.},
	number = {2},
	journal = {Journal of Computing Sciences in Colleges},
	author = {Clincy, Victor A.},
	month = dec,
	year = {2003},
	pages = {278--287},
}

@inproceedings{oliveiraSoftwareProjectManagers2016,
	address = {New York, NY, USA},
	series = {{ESEM} '16},
	title = {Software {Project} {Managers}' {Perceptions} of {Productivity} {Factors}: {Findings} from a {Qualitative} {Study}},
	isbn = {978-1-4503-4427-2},
	shorttitle = {Software {Project} {Managers}' {Perceptions} of {Productivity} {Factors}},
	url = {https://doi.org/10.1145/2961111.2962626},
	doi = {10.1145/2961111.2962626},
	abstract = {Context -- Developers' productivity plays an important role in software development organizations; however, in many cases the management of such human capital is mainly based on how project managers perceive productivity. Therefore, it is important to investigate what these perceptions are in practice. Goal -- This study's main goal is to understand project managers' perception regarding developers' productivity. Method -- We employed a qualitative research methodology using semi-structured interviews for data collection. We interviewed 12 managers from three software development organizations in the city of Manaus (Brazil). Results -- We identified that the managers' perceptions about developers' productivity are influenced by four different factors: (1) tasks delivered on time, (2) produced artifacts that do not need rework, (3) products that meet stakeholders' expectations, and (4) personal behavior such as focus and proactivity. Conclusions -- This qualitative study shows a perception of developers' productivity different from that presented in other research papers, and suggests that human factors play an important role in managers' perceptions about productivity. Future work will investigate how these perceptions concretely influence developers' productivity, and how they relate to the existing developers' productivity factors in the literature.},
	urldate = {2022-12-12},
	booktitle = {Proceedings of the 10th {ACM}/{IEEE} {International} {Symposium} on {Empirical} {Software} {Engineering} and {Measurement}},
	publisher = {Association for Computing Machinery},
	author = {Oliveira, Edson and Conte, Tayana and Cristo, Marco and Mendes, Emilia},
	month = sep,
	year = {2016},
	keywords = {Perception, Productivity, Qualitative Study},
	pages = {1--6},
}

@article{maxwellBenchmarkingSoftwareDevelopmentProductivity2000,
	title = {Benchmarking {Software}-{Development} {Productivity}},
	volume = {17},
	issn = {0740-7459},
	url = {https://doi.org/10.1109/52.820015},
	doi = {10.1109/52.820015},
	abstract = {This article examines a statistical analysis of a productivity variation involving a unique database containing 206 business software projects from 26 Finnish companies. The authors examine differences in the factors explaining productivity in the banking, insurance, manufacturing, wholesale/retail, and public administration sectors. The authors provide productivity benchmarking equations that are useful both for estimating expected productivity at the start of a new project and for benchmarking a completed project for each business sector.},
	number = {1},
	urldate = {2022-12-12},
	journal = {IEEE Software},
	author = {Maxwell, Katrina D. and Forselius, Pekka},
	month = jan,
	year = {2000},
	pages = {80--88},
}

@inproceedings{canedoFactorsAffectingSoftware2019,
	address = {New York, NY, USA},
	series = {{SBES} '19},
	title = {Factors {Affecting} {Software} {Development} {Productivity}: {An} empirical study},
	isbn = {978-1-4503-7651-8},
	shorttitle = {Factors {Affecting} {Software} {Development} {Productivity}},
	url = {https://doi.org/10.1145/3350768.3352491},
	doi = {10.1145/3350768.3352491},
	abstract = {The competitiveness has demanded from the software industry shorter delivery times for its products resulting in optimized life cycles, generating a need to increase its performance to maintain competitiveness in the markets where they operate. This context has made productivity study so fundamental that organizations not only evaluate their performance, but also provide means to improve it. The main goal of this paper is to investigate which factors affect productivity in software development projects and in open-source projects. In this work a Systematic Literature Review (SLR) was carried out in order to answer the research questions and a survey with practitioners community about their perception in relation to the factors of the productivity of the team. This empirical study led to the discovery of interesting factors that show how the different factors do (or do not) affect productivity. It was also found out that some factors appear to allow independence and responsibility of team, while others appear to cause a better distribution of tasks. The results show how factors such as people, product, organization, investment in technology, lack of contractual relations and engagement of open-source project contributors influence productivity.},
	urldate = {2022-12-12},
	booktitle = {Proceedings of the {XXXIII} {Brazilian} {Symposium} on {Software} {Engineering}},
	publisher = {Association for Computing Machinery},
	author = {Canedo, Edna Dias and Santos, Giovanni Almeida},
	month = sep,
	year = {2019},
	keywords = {Empirical study, Influence Factors, Measurement, Metrics, Productivity},
	pages = {307--316},
}

@inproceedings{bendifallahWorkStructuresShifts1989,
	address = {New York, NY, USA},
	series = {{ICSE} '89},
	title = {Work structures and shifts: an empirical analysis of software specification teamwork},
	isbn = {978-0-8186-1941-0},
	shorttitle = {Work structures and shifts},
	url = {https://doi.org/10.1145/74587.74624},
	doi = {10.1145/74587.74624},
	urldate = {2022-12-12},
	booktitle = {Proceedings of the 11th international conference on {Software} engineering},
	publisher = {Association for Computing Machinery},
	author = {Bendifallah, Salah and Scacchi, Walt},
	month = may,
	year = {1989},
	keywords = {Conway's law, empirical studies, software specification, tearmwork},
	pages = {260--270},
}

@inproceedings{millerHowWasYour2021,
	title = {"{How} {Was} {Your} {Weekend}?" {Software} {Development} {Teams} {Working} {From} {Home} {During} {COVID}-19},
	shorttitle = {"{How} {Was} {Your} {Weekend}?},
	doi = {10.1109/ICSE43902.2021.00064},
	abstract = {The mass shift to working at home during the COVID-19 pandemic radically changed the way many software development teams collaborate and communicate. To investigate how team culture and team productivity may also have been affected, we conducted two surveys at a large software company. The first, an exploratory survey during the early months of the pandemic with 2,265 developer responses, revealed that many developers faced challenges reaching milestones and that their team productivity had changed. We also found through qualitative analysis that important team culture factors such as communication and social connection had been affected. For example, the simple phrase "How was your weekend?" had become a subtle way to show peer support. In our second survey, we conducted a quantitative analysis of the team cultural factors that emerged from our first survey to understand the prevalence of the reported changes. From 608 developer responses, we found that 74\% of these respondents missed social interactions with colleagues and 51\% reported a decrease in their communication ease with colleagues. We used data from the second survey to build a regression model to identify important team culture factors for modeling team productivity. We found that the ability to brainstorm with colleagues, difficulty communicating with colleagues, and satisfaction with interactions from social activities are important factors that are associated with how developers report their software development team's productivity. Our findings inform how managers and leaders in large software companies can support sustained team productivity during times of crisis and beyond.},
	booktitle = {2021 {IEEE}/{ACM} 43rd {International} {Conference} on {Software} {Engineering} ({ICSE})},
	author = {Miller, Courtney and Rodeghero, Paige and Storey, Margaret-Anne and Ford, Denae and Zimmermann, Thomas},
	month = may,
	year = {2021},
	note = {ISSN: 1558-1225},
	keywords = {Brain modeling, COVID-19, Companies, Data models, Pandemics, Productivity, Software},
	pages = {624--636},
}

@inproceedings{cataldoSociotechnicalCongruenceFramework2008,
	address = {New York, NY, USA},
	series = {{ESEM} '08},
	title = {Socio-technical congruence: a framework for assessing the impact of technical and work dependencies on software development productivity},
	isbn = {978-1-59593-971-5},
	shorttitle = {Socio-technical congruence},
	url = {https://doi.org/10.1145/1414004.1414008},
	doi = {10.1145/1414004.1414008},
	abstract = {The identification and management of work dependencies is a fundamental challenge in software development organizations. This paper argues that modularization, the traditional technique intended to reduce interdependencies among components of a system, has serious limitations in the context of software development. We build on the idea of congruence, proposed in our prior work, to examine the relationship between the structure of technical and work dependencies and the impact of dependencies on software development productivity. Our empirical evaluation of the congruence framework showed that when developers' coordination patterns are congruent with their coordination needs, the resolution time of modification requests was significantly reduced. Furthermore, our analysis highlights the importance of identifying the "right" set of technical dependencies that drive the coordination requirements among software developers. Call and data dependencies appear to have far less impact than logical dependencies.},
	urldate = {2022-12-12},
	booktitle = {Proceedings of the {Second} {ACM}-{IEEE} international symposium on {Empirical} software engineering and measurement},
	publisher = {Association for Computing Machinery},
	author = {Cataldo, Marcelo and Herbsleb, James D. and Carley, Kathleen M.},
	month = oct,
	year = {2008},
	keywords = {collaborative software development, coordination, software dependencies},
	pages = {2--11},
}

@inproceedings{albrecht1979measuring,
	title = {Measuring application development productivity},
	booktitle = {Proc. {Joint} share, guide, and {IBM} application development symposium, 1979},
	author = {Albrecht, Allan J},
	year = {1979},
}

@inproceedings{devanbuAnalyticalEmpiricalEvaluation1996,
	address = {USA},
	series = {{ICSE} '96},
	title = {Analytical and empirical evaluation of software reuse metrics},
	isbn = {978-0-8186-7246-0},
	abstract = {How much can be saved by using existing software components when developing new software systems? With the increasing adoption of reuse methods and technologies, this question becomes critical. However, directly tracking the actual cost savings due to reuse is difficult. A worthy goal would be to develop a method of measuring the savings indirectly by analyzing the code for reuse of components. The focus of the paper is to evaluate how well several published software reuse metrics measure the "time, money and quality" benefits of software reuse. We conduct this evaluation both analytically and empirically. On the analytic front, we introduce some properties that should arguably hold of any measure of "time, money and quality" benefit due to reuse. We assess several existing software reuse metrics using these properties. Empirically, we constructed a toolset (using GEN+S) to gather data on all published reuse metrics from CS+ code; then, using some productivity and quality data from "nearly replicated" student projects at the University of Maryland, we evaluate the relationship between the known metrics and the process data. Our empirical study sheds some light on the applicability of our different analytic properties, and has raised some practical issues to be addressed as we undertake broader study of reuse metrics in industrial projects.},
	urldate = {2022-12-12},
	booktitle = {Proceedings of the 18th international conference on {Software} engineering},
	publisher = {IEEE Computer Society},
	author = {Devanbu, Prem and Karstu, Sakke and Melo, Walcélio and Thomas, William},
	month = may,
	year = {1996},
	keywords = {analytical evaluation, cost savings, empirical evaluation, human resource management, industrial projects, productivity data, quality data, savings measurement, software components, software cost estimation, software metrics, software reusability, software reuse metrics, software system development, software tools, student projects, toolset},
	pages = {189--199},
}

@article{lakhanpalUnderstandingFactorsInfluencing1993,
	title = {Understanding the factors influencing the performance of software development groups: {An} exploratory group-level analysis},
	volume = {35},
	issn = {0950-5849},
	shorttitle = {Understanding the factors influencing the performance of software development groups},
	url = {https://www.sciencedirect.com/science/article/pii/0950584993900444},
	doi = {10.1016/0950-5849(93)90044-4},
	abstract = {The increasing complexity and size of software systems makes the performance and productivity of the software development activity a critical issue. Most studies of software development performance to date have focused on individual software developers. However, software development, especially for large-scale software projects, is a group effort in which the characteristics of the group itself play an important role. The paper examines the variation in the performance of software development groups as a function of the characteristics of the group itself. Using data from 31 software development groups, we examined the influence of the group's cohesiveness, total experience in software development and capability on the group's performance level. The influence of cohesiveness and capability was found to be strong and significant while the influence of experience was the weakest. The results from this exploratory research provide interesting insights into the issue of software development performance and offer important implications for development teams working on software projects.},
	language = {en},
	number = {8},
	urldate = {2022-12-12},
	journal = {Information and Software Technology},
	author = {Lakhanpal, B},
	month = aug,
	year = {1993},
	keywords = {group cohesiveness, software development, software development group performance, software development groups},
	pages = {468--473},
}

@inproceedings{markNeuroticsCanFocus2016,
	address = {New York, NY, USA},
	series = {{CHI} '16},
	title = {Neurotics {Can}'t {Focus}: {An} in situ {Study} of {Online} {Multitasking} in the {Workplace}},
	isbn = {978-1-4503-3362-7},
	shorttitle = {Neurotics {Can}'t {Focus}},
	url = {https://doi.org/10.1145/2858036.2858202},
	doi = {10.1145/2858036.2858202},
	abstract = {In HCI research, attention has focused on understanding external influences on workplace multitasking. We explore instead how multitasking might be influenced by individual factors: personality, stress, and sleep. Forty information workers' online activity was tracked over two work weeks. The median duration of online screen focus was 40 seconds. The personality trait of Neuroticism was associated with shorter online focus duration and Impulsivity-Urgency was associated with longer online focus duration. Stress and sleep duration showed trends to be inversely associated with online focus. Shorter focus duration was associated with lower assessed productivity at day's end. Factor analysis revealed a factor of lack of control which significantly predicts multitasking. Our results suggest that there could be a trait for distractibility where some individuals are susceptible to online attention shifting in the workplace. Our results have implications for information systems (e.g. educational systems, game design) where attention focus is key.},
	urldate = {2022-12-12},
	booktitle = {Proceedings of the 2016 {CHI} {Conference} on {Human} {Factors} in {Computing} {Systems}},
	publisher = {Association for Computing Machinery},
	author = {Mark, Gloria and Iqbal, Shamsi T. and Czerwinski, Mary and Johns, Paul and Sano, Akane},
	month = may,
	year = {2016},
	keywords = {focus, information work, multitasking, personality, productivity, sleep, stress},
	pages = {1739--1744},
}

@inproceedings{kimUnderstandingPersonalProductivity2019,
	address = {New York, NY, USA},
	series = {{CHI} '19},
	title = {Understanding {Personal} {Productivity}: {How} {Knowledge} {Workers} {Define}, {Evaluate}, and {Reflect} on {Their} {Productivity}},
	isbn = {978-1-4503-5970-2},
	shorttitle = {Understanding {Personal} {Productivity}},
	url = {https://doi.org/10.1145/3290605.3300845},
	doi = {10.1145/3290605.3300845},
	abstract = {Productivity tracking tools often determine productivity based on the time interacting with work-related applications. To deconstruct productivity's diverse and nebulous nature, we investigate how knowledge workers conceptualize personal productivity and delimit productive tasks in both work and non-work contexts. We report a 2-week diary study followed by a semi-structured interview with 24 knowledge workers. Participants captured productive activities and provided the rationale for why the activities were assessed to be productive. They reported a wide range of productive activities beyond typical desk-bound work-ranging from having a personal conversation with dad to getting a haircut. We found six themes that characterize the productivity assessment-work product, time management, worker's state, attitude toward work, impact \& benefit, and compound task and identified how participants interleaved multiple facets when assessing their productivity. We discuss how these findings could inform the design of a comprehensive productivity tracking system that covers a wide range of productive activities.},
	urldate = {2022-12-12},
	booktitle = {Proceedings of the 2019 {CHI} {Conference} on {Human} {Factors} in {Computing} {Systems}},
	publisher = {Association for Computing Machinery},
	author = {Kim, Young-Ho and Choe, Eun Kyoung and Lee, Bongshin and Seo, Jinwook},
	month = may,
	year = {2019},
	keywords = {diary study, knowledge worker, personal informatics, productivity, productivity tracking, self-monitoring, self-tracking},
	pages = {1--12},
}

@article{meyerSoftwareDevelopersPerceptions2014,
	title = {Software {Developers}’ {Perceptions} of {Productivity}},
	url = {https://www.zora.uzh.ch/id/eprint/98324},
	doi = {10.5167/UZH-98324},
	urldate = {2022-12-12},
	author = {Meyer, André N. and Fritz, Thomas and Murphy, Gail C. and Zimmermann, Thomas},
	month = nov,
	year = {2014},
	note = {Publisher: s.n.},
}

@incollection{koWhyWeShould2019,
	address = {Berkeley, CA},
	title = {Why {We} {Should} {Not} {Measure} {Productivity}},
	isbn = {978-1-4842-4221-6},
	url = {https://doi.org/10.1007/978-1-4842-4221-6_3},
	abstract = {Software moves faster every year. Markets shift rapidly, releases are ever more frequent, and languages, APIs, and platforms evolve at a relentless pace. And so interest in productivity, both by developers who want to keep up with these changes, but also by managers and organizations who need to compete, appears entirely rational. Moreover, improving software faster holds even greater promise to the rest of humanity: getting more work done with less effort means may mean an increased quality of life for everyone.},
	language = {en},
	urldate = {2022-12-12},
	booktitle = {Rethinking {Productivity} in {Software} {Engineering}},
	publisher = {Apress},
	author = {Ko, Amy J.},
	editor = {Sadowski, Caitlin and Zimmermann, Thomas},
	year = {2019},
	doi = {10.1007/978-1-4842-4221-6_3},
	pages = {21--26},
}

@book{jonesProgrammingProductivity1985,
	address = {USA},
	title = {Programming productivity},
	isbn = {978-0-07-032811-2},
	publisher = {McGraw-Hill, Inc.},
	author = {Jones, Capers},
	year = {1985},
}

@inproceedings{sadowskiHowDevelopersSearch2015,
	address = {New York, NY, USA},
	series = {{ESEC}/{FSE} 2015},
	title = {How developers search for code: a case study},
	isbn = {978-1-4503-3675-8},
	shorttitle = {How developers search for code},
	url = {https://doi.org/10.1145/2786805.2786855},
	doi = {10.1145/2786805.2786855},
	abstract = {With the advent of large code repositories and sophisticated search capabilities, code search is increasingly becoming a key software development activity. In this work we shed some light into how developers search for code through a case study performed at Google, using a combination of survey and log-analysis methodologies. Our study provides insights into what developers are doing and trying to learn when per- forming a search, search scope, query properties, and what a search session under different contexts usually entails. Our results indicate that programmers search for code very frequently, conducting an average of five search sessions with 12 total queries each workday. The search queries are often targeted at a particular code location and programmers are typically looking for code with which they are somewhat familiar. Further, programmers are generally seeking answers to questions about how to use an API, what code does, why something is failing, or where code is located.},
	urldate = {2022-12-12},
	booktitle = {Proceedings of the 2015 10th {Joint} {Meeting} on {Foundations} of {Software} {Engineering}},
	publisher = {Association for Computing Machinery},
	author = {Sadowski, Caitlin and Stolee, Kathryn T. and Elbaum, Sebastian},
	month = aug,
	year = {2015},
	keywords = {code search, developer tools, user evaluation},
	pages = {191--201},
}

@article{stoleeSolvingSearchSource2014,
	title = {Solving the {Search} for {Source} {Code}},
	volume = {23},
	issn = {1049-331X},
	url = {https://doi.org/10.1145/2581377},
	doi = {10.1145/2581377},
	abstract = {Programmers frequently search for source code to reuse using keyword searches. The search effectiveness in facilitating reuse, however, depends on the programmer's ability to specify a query that captures how the desired code may have been implemented. Further, the results often include many irrelevant matches that must be filtered manually. More semantic search approaches could address these limitations, yet existing approaches are either not flexible enough to find approximate matches or require the programmer to define complex specifications as queries. We propose a novel approach to semantic code search that addresses several of these limitations and is designed for queries that can be described using a concrete input/output example. In this approach, programmers write lightweight specifications as inputs and expected output examples. Unlike existing approaches to semantic search, we use an SMT solver to identify programs or program fragments in a repository, which have been automatically transformed into constraints using symbolic analysis, that match the programmer-provided specification. We instantiated and evaluated this approach in subsets of three languages, the Java String library, Yahoo! Pipes mashup language, and SQL select statements, exploring its generality, utility, and trade-offs. The results indicate that this approach is effective at finding relevant code, can be used on its own or to filter results from keyword searches to increase search precision, and is adaptable to find approximate matches and then guide modifications to match the user specifications when exact matches do not already exist. These gains in precision and flexibility come at the cost of performance, for which underlying factors and mitigation strategies are identified.},
	number = {3},
	urldate = {2022-12-12},
	journal = {ACM Transactions on Software Engineering and Methodology},
	author = {Stolee, Kathryn T. and Elbaum, Sebastian and Dobos, Daniel},
	month = jun,
	year = {2014},
	keywords = {SMT solvers, Semantic code search, lightweight specification, symbolic analysis},
	pages = {26:1--26:45},
}

@inproceedings{simArchetypalSourceCode1998,
	title = {Archetypal source code searches: a survey of software developers and maintainers},
	shorttitle = {Archetypal source code searches},
	doi = {10.1109/WPC.1998.693351},
	abstract = {We have conducted a survey to generate archetypes of source code searching by programmers across maintenance tasks. Using a questionnaire on a web page, we obtained 69 responses from readers of 7 newsgroups. Respondents were asked about their source code searching habits: what tools they used, why they searched, and what they searched for. The four most common search targets were function definitions, all uses of a function, variable definitions, and all uses of a variable. The most common search motivations were defect repair, code reuse, program understanding, feature addition, and impact analysis. Eleven archetypes were generated from the anecdotes and results. The implications and practical applications of these findings and method are discussed.},
	booktitle = {Proceedings. 6th {International} {Workshop} on {Program} {Comprehension}. {IWPC}'98 ({Cat}. {No}.{98TB100242})},
	author = {Sim, S.E. and Clarke, C.L.A. and Holt, R.C.},
	month = jun,
	year = {1998},
	note = {ISSN: 1092-8138},
	keywords = {Application software, Cognitive science, Computer bugs, Computer science, Ear, Electrical capacitance tomography, Maintenance engineering, Programming profession, Read only memory, Software maintenance},
	pages = {180--187},
}

@incollection{cockburnCostsBenefitsPair2001,
	address = {USA},
	title = {The costs and benefits of pair programming},
	isbn = {978-0-201-71040-3},
	urldate = {2022-12-12},
	booktitle = {Extreme programming examined},
	publisher = {Addison-Wesley Longman Publishing Co., Inc.},
	author = {Cockburn, Alistair and Williams, Laurie},
	month = may,
	year = {2001},
	pages = {223--243},
}

@inproceedings{grossmanSurveySoftwareLearnability2009,
	address = {New York, NY, USA},
	series = {{CHI} '09},
	title = {A survey of software learnability: metrics, methodologies and guidelines},
	isbn = {978-1-60558-246-7},
	shorttitle = {A survey of software learnability},
	url = {https://doi.org/10.1145/1518701.1518803},
	doi = {10.1145/1518701.1518803},
	abstract = {It is well-accepted that learnability is an important aspect of usability, yet there is little agreement as to how learnability should be defined, measured, and evaluated. In this paper, we present a survey of the previous definitions, metrics, and evaluation methodologies which have been used for software learnability. Our survey of evaluation methodologies leads us to a new question-suggestion protocol, which, in a user study, was shown to expose a significantly higher number of learnability issues in comparison to a more traditional think-aloud protocol. Based on the issues identified in our study, we present a classification system of learnability issues, and demonstrate how these categories can lead to guidelines for addressing the associated challenges.},
	urldate = {2022-12-12},
	booktitle = {Proceedings of the {SIGCHI} {Conference} on {Human} {Factors} in {Computing} {Systems}},
	publisher = {Association for Computing Machinery},
	author = {Grossman, Tovi and Fitzmaurice, George and Attar, Ramtin},
	month = apr,
	year = {2009},
	keywords = {evaluation, learnability, learning, question-suggestion, software, think-aloud, usability},
	pages = {649--658},
}

@article{waiteStudentCultureVs2004,
	title = {Student culture vs group work in computer science},
	volume = {36},
	issn = {0097-8418},
	url = {https://doi.org/10.1145/1028174.971308},
	doi = {10.1145/1028174.971308},
	abstract = {Our industrial advisory boards tell us that our students are well prepared technically, but they lack important group work skills. Simply adding project courses and requiring that assignments be done in groups has not improved the situation. A careful study of student culture in Computer Science has uncovered barriers to collaboration, which can be overcome only by pervasive changes in the way we approach our curriculum.},
	number = {1},
	urldate = {2022-12-12},
	journal = {ACM SIGCSE Bulletin},
	author = {Waite, William M. and Jackson, Michele H. and Diwan, Amer and Leonardi, Paul M.},
	month = mar,
	year = {2004},
	keywords = {CS educational research, classroom management, communication skills, course pedagogy, curriculum issues},
	pages = {12--16},
}

@article{payneAnimatedDemonstrationsExploratory1992,
	title = {Animated demonstrations for exploratory learners},
	volume = {4},
	issn = {09535438},
	url = {https://academic.oup.com/iwc/article-lookup/doi/10.1016/0953-5438(92)90010-D},
	doi = {10.1016/0953-5438(92)90010-D},
	language = {en},
	number = {1},
	urldate = {2022-12-12},
	journal = {Interacting with Computers},
	author = {Payne, Stephen J. and Chesworth, Louise and Hill, Elaine},
	month = apr,
	year = {1992},
	pages = {3--22},
}

@article{devaney2009impact,
	title = {Impact of video tutorials in an online educational statistics course},
	volume = {5},
	number = {4},
	journal = {Journal of Online Learning and Teaching},
	author = {DeVaney, Thomas A},
	year = {2009},
	note = {Publisher: Multimedia Educational Resource for Learning and Online Teaching (MERLOT)},
	pages = {600--608},
}

@article{mestreStudentPreferenceTutorial2012,
	title = {Student preference for tutorial design: a usability study},
	volume = {40},
	issn = {0090-7324},
	shorttitle = {Student preference for tutorial design},
	url = {https://doi.org/10.1108/00907321211228318},
	doi = {10.1108/00907321211228318},
	abstract = {Purpose – This article aims to report on a usability study to assess whether students performed better after working through a screencast library tutorial or a web‐based tutorial with screenshots. Design/methodology/approach – This qualitative study asked 21 students from diverse backgrounds and learning styles to take two learning style inventories prior to a usability study. The students then went through two short tutorials (a static web page tutorial with screenshots and a Camtasia screencast (video) tutorial, as well as a pre‐ and post‐test and debriefing for each. The “think aloud” protocol was used as their movements and voices were recorded using the Camtasia software. Findings – The results of this study indicate that across all learning preferences students performed much better in recreating tasks when they used a static web page with screen shots than they did after viewing a screencasting tutorial. Practical implications – Suggestions are offered for ways to create tutorials that are effective for multiple learning styles that will fit into a student's workflow. Originality/value – Results of this study may help inform other librarians in ways to effectively design tutorials and learning objects to meet student needs.},
	number = {2},
	urldate = {2022-12-12},
	journal = {Reference Services Review},
	author = {Mestre, Lori S.},
	month = jan,
	year = {2012},
	note = {Publisher: Emerald Group Publishing Limited},
	keywords = {Diversity, Learning styles, Library instruction, Online learning, Tutorials, User studies},
	pages = {258--276},
}

@article{vandermeijComparisonPaperbasedVideo2014,
	title = {A comparison of paper-based and video tutorials for software learning},
	volume = {78},
	issn = {0360-1315},
	url = {https://www.sciencedirect.com/science/article/pii/S0360131514001353},
	doi = {10.1016/j.compedu.2014.06.003},
	abstract = {Instruction on software usage has long been dominated by the paper-based tutorial. This dominance is now being challenged with the rise of facilities for producing and publishing recorded demonstrations (video). Typically, each instructional medium has its own qualities. The present study aimed to optimize the design of a video tutorial for software training by attending to both its strengths and its weaknesses vis-à-vis a paper-based tutorial. Based on a distinction between two functionally different components in software tutorials, four tutorial configurations were compared: Paper-based, Mixed A (paper-based preview and video procedure), Mixed B (video preview and paper-based procedure), and Video. The 111 fifth and sixth grade participants (mean age 11.8) received instructions about Word's formatting options. The findings indicated significant and substantial improvements from pre-test to training in all conditions. In addition, participants in the Mixed A, Mixed B, and Video conditions outperformed those in the Paper-based condition. Significant and substantial learning gains were found from pre-test to post-test. Both the Mixed B and Video conditions outperformed the Paper-based condition. The success of the Mixed A, Mixed B, and Video tutorials is ascribed to the use of design guidelines for software training that direct the designer to optimize video's strong qualities and moderate or reduce its relative weaknesses.},
	language = {en},
	urldate = {2022-12-12},
	journal = {Computers \& Education},
	author = {van der Meij, Hans and van der Meij, Jan},
	month = sep,
	year = {2014},
	keywords = {Computer-mediated communication, Teaching/learning strategies, Tutorials, Video},
	pages = {150--159},
}

@article{hymanCreativeChaosHighperformance1993,
	title = {Creative chaos in high-performance teams: an experience report},
	volume = {36},
	issn = {0001-0782},
	shorttitle = {Creative chaos in high-performance teams},
	url = {https://doi.org/10.1145/163430.163444},
	doi = {10.1145/163430.163444},
	number = {10},
	urldate = {2022-12-12},
	journal = {Communications of the ACM},
	author = {Hyman, Risa B.},
	month = oct,
	year = {1993},
	keywords = {random paradigm organizations},
	pages = {57--60},
}

@article{smiteEmpiricalEvidenceGlobal2010,
	title = {Empirical evidence in global software engineering: a systematic review},
	volume = {15},
	issn = {1382-3256},
	shorttitle = {Empirical evidence in global software engineering},
	url = {https://doi.org/10.1007/s10664-009-9123-y},
	doi = {10.1007/s10664-009-9123-y},
	abstract = {Recognized as one of the trends of the 21st century, globalization of the world economies brought significant changes to nearly all industries, and in particular it includes software development. Many companies started global software engineering (GSE) to benefit from cheaper, faster and better development of software systems, products and services. However, empirical studies indicate that achieving these benefits is not an easy task. Here, we report our findings from investigating empirical evidence in GSE-related research literature. By conducting a systematic review we observe that the GSE field is still immature. The amount of empirical studies is relatively small. The majority of the studies represent problem-oriented reports focusing on different aspects of GSE management rather than in-depth analysis of solutions for example in terms of useful practices or techniques. Companies are still driven by cost reduction strategies, and at the same time, the most frequently discussed recommendations indicate a necessity of investments in travelling and socialization. Thus, at the same time as development goes global there is an ambition to minimize geographical, temporal and cultural separation. These are normally integral parts of cross-border collaboration. In summary, the systematic review results in several descriptive classifications of the papers on empirical studies in GSE and also reports on some best practices identified from literature.},
	number = {1},
	urldate = {2022-12-12},
	journal = {Empirical Software Engineering},
	author = {Šmite, Darja and Wohlin, Claes and Gorschek, Tony and Feldt, Robert},
	month = feb,
	year = {2010},
	keywords = {Distributed software engineering, Empirical evidence, Empirical studies, Global software engineering, Systematic review},
	pages = {91--118},
}

@inproceedings{birdPuttingItAll2009,
	address = {Bengaluru-Mysuru, India},
	series = {{ISSRE}'09},
	title = {Putting it all together: using socio-technical networks to predict failures},
	isbn = {978-1-4244-5375-7},
	shorttitle = {Putting it all together},
	abstract = {Studies have shown that social factors in development organizations have a dramatic effect on software quality. Separately, program dependency information has also been used successfully to predict which software components are more fault prone. Interestingly, the influence of these two phenomena have only been studied separately. Intuition and practical experience suggests, however, that task assignment (i.e. who worked on which components and how much) and dependency structure (which components have dependencies on others) together interact to influence the quality of the resulting software. We study the influence of combined socio-technical software networks on the fault-proneness of individual software components within a system. The network properties of a software component in this combined network are able to predict if an entity is failure prone with greater accuracy than prior methods which use dependency or contribution information in isolation. We evaluate our approach in different settings by using it on Windows Vista and across six releases of the Eclipse development environment including using models built from one release to predict failure prone components in the next release. We compare this to previous work. In every case, our method performs as well or better and is able to more accurately identify those software components that have more post-release failures, with precision and recall rates as high as 85\%.},
	urldate = {2022-12-12},
	booktitle = {Proceedings of the 20th {IEEE} international conference on software reliability engineering},
	publisher = {IEEE Press},
	author = {Bird, Christian and Nagappan, Nachiappan and Gall, Harald and Murphy, Brendan and Devanbu, Premkumar},
	month = nov,
	year = {2009},
	pages = {109--119},
}

@inproceedings{nagappanInfluenceOrganizationalStructure2008,
	address = {New York, NY, USA},
	series = {{ICSE} '08},
	title = {The influence of organizational structure on software quality: an empirical case study},
	isbn = {978-1-60558-079-1},
	shorttitle = {The influence of organizational structure on software quality},
	url = {https://doi.org/10.1145/1368088.1368160},
	doi = {10.1145/1368088.1368160},
	abstract = {Often software systems are developed by organizations consisting of many teams of individuals working together. Brooks states in the Mythical Man Month book that product quality is strongly affected by organization structure. Unfortunately there has been little empirical evidence to date to substantiate this assertion. In this paper we present a metric scheme to quantify organizational complexity, in relation to the product development process to identify if the metrics impact failure-proneness. In our case study, the organizational metrics when applied to data from Windows Vista were statistically significant predictors of failure-proneness. The precision and recall measures for identifying failure-prone binaries, using the organizational metrics, was significantly higher than using traditional metrics like churn, complexity, coverage, dependencies, and pre-release bug measures that have been used to date to predict failure-proneness. Our results provide empirical evidence that the organizational metrics are related to, and are effective predictors of failure-proneness.},
	urldate = {2022-12-12},
	booktitle = {Proceedings of the 30th international conference on {Software} engineering},
	publisher = {Association for Computing Machinery},
	author = {Nagappan, Nachiappan and Murphy, Brendan and Basili, Victor},
	month = may,
	year = {2008},
	keywords = {code churn, developers, empirical studies, failures, organizational structure, software mining},
	pages = {521--530},
}

@inproceedings{demarcoProgrammerPerformanceEffects1985,
	address = {Washington, DC, USA},
	series = {{ICSE} '85},
	title = {Programmer performance and the effects of the workplace},
	isbn = {978-0-8186-0620-5},
	abstract = {Wide variation in programmer performance has been frequently reported in the literature [1, 2, 3]. In the absence of other explanation, most managers have come to accept that the variation is due to individual characteristics. The presumption that there are order-of-magnitude differences in individual performance makes accurate cost projection seem nearly impossible. In an extensive study, 166 programmers from 35 different organizations, participated in a one-day implementation benchmarking exercise. While there were wide variations across the sample, we found evidence that characteristics of the workplace and of the organization seemed to explain a significant part of the difference.},
	urldate = {2022-12-12},
	booktitle = {Proceedings of the 8th international conference on {Software} engineering},
	publisher = {IEEE Computer Society Press},
	author = {DeMarco, Tom and Lister, Tim},
	month = aug,
	year = {1985},
	keywords = {management isssue, productivity, programmer workplace},
	pages = {268--272},
}

@article{sackmanExploratoryExperimentalStudies1968,
	title = {Exploratory experimental studies comparing online and offline programming performance},
	volume = {11},
	issn = {0001-0782},
	url = {https://doi.org/10.1145/362851.362858},
	doi = {10.1145/362851.362858},
	number = {1},
	urldate = {2022-12-12},
	journal = {Communications of the ACM},
	author = {Sackman, H. and Erikson, W. J. and Grant, E. E.},
	month = jan,
	year = {1968},
	keywords = {analysis of variance, basic programming knowledge test, debugging effectiveness, experienced programmer study, factor analysis application, online vs. offline performance, programmer individual differences, programmer trainee performance, programmer/computer communication, programming cost effectiveness, programming experimental-empirical studies, programming performance, time sharing vs. batch processing},
	pages = {3--11},
}

@inproceedings{chenWhyItImportant2017,
	title = {Why {Is} {It} {Important} to {Measure} {Maintainability} and {What} {Are} the {Best} {Ways} to {Do} {It}?},
	doi = {10.1109/ICSE-C.2017.75},
	abstract = {Being highly maintainable is the key to reducing approximately 75\% of most systems' life cycle costs. Software maintainability is defined as the ease with which a software system or a component can be modified, to correct faults, improve performance or other attributes, or adapt to a changed environment. There exist metrics that can help developers measure and analyze the maintainability level of a project objectively. Most of these metrics involve automated analysis of the code. In this extended abstract paper, we addressed the importance of understanding software maintainability, explored some of the best ways to measure maintainability and briefly described a comparison study we conducted between automated maintainability metrics and human-assessed maintainability metrics through a controlled experiment by performing change-request modifications on open source software (OSS) projects.},
	booktitle = {2017 {IEEE}/{ACM} 39th {International} {Conference} on {Software} {Engineering} {Companion} ({ICSE}-{C})},
	author = {Chen, Celia and Alfayez, Reem and Srisopha, Kamonphop and Boehm, Barry and Shi, Lin},
	month = may,
	year = {2017},
	keywords = {Computer bugs, Maintenance engineering, Organizations, Software, Software engineering, Software measurement},
	pages = {377--378},
}
